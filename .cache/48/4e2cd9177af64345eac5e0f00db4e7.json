{"id":"j4rD","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"./packing_util","loc":{"line":17,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js"},{"name":"./shader_compiler","loc":{"line":18,"column":34},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/mirror_pad_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.MirrorPadPackedProgram=void 0;var e=require(\"./packing_util\"),n=require(\"./shader_compiler\");class t{constructor(t,r,s){this.variableNames=[\"x\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r.map((e,n)=>e[0]+t[n]+e[1]);const o=t.length,u=(0,n.getCoordsDataType)(o),$=r.map(e=>e[0]).join(\",\"),c=r.map((e,n)=>e[0]+t[n]).join(\",\"),a=(0,e.getChannels)(\"rc\",o),i=(0,e.getChannels)(\"source\",o),l=`${a[o-1]} < ${this.outputShape[o-1]}`,g=1===o?\"source\":`vec2(${i.slice(-2).join()})`,p=\"reflect\"===s?0:1;let h=\"\";if(1===o){const e=`\\n        ${u} source = rc;\\n        if (source < start) {\\n          source = start * 2 - source - ${p};\\n        } else if (source >= end) {\\n          source = (end - 1) * 2 - source + ${p};\\n        }\\n        source -= start;\\n      `;h=`\\n        ${u} rc = outputLoc;\\n        ${e}\\n        result[0] = getChannel(getX(${i.join()}), ${g});\\n        ${a[o-1]} += 1;\\n        if(${l}) {\\n          ${e}\\n          result[1] = getChannel(getX(${i.join()}), ${g});\\n        }\\n      `}else{const e=`\\n        ${u} source = rc;\\n        ${u} lt = ${u}(lessThan(source, start));\\n        ${u} gte = ${u}(greaterThanEqual(source, end));\\n        ${u} orig = 1 - (lt + gte);\\n        source = orig * source +\\n                lt * (start * 2 - source - ${p}) +\\n                gte * ((end - 1) * 2 - source + ${p});\\n        source -= start;\\n      `;h=`\\n        ${u} rc = outputLoc;\\n        ${e}\\n        result[0] = getChannel(getX(${i.join()}), ${g});\\n        ${a[o-1]} += 1;\\n        if(${l}) {\\n          ${e}\\n          result[1] = getChannel(getX(${i.join()}), ${g});\\n        }\\n        rc = outputLoc;\\n        ${a[o-2]} += 1;\\n        if(${a[o-2]} < ${this.outputShape[o-2]}) {\\n          ${e}\\n          result[2] = getChannel(getX(${i.join()}), ${g});\\n          ${a[o-1]} += 1;\\n          if(${l}) {\\n            ${e}\\n            result[3] = getChannel(getX(${i.join()}), ${g});\\n          }\\n        }\\n      `}this.userCode=`\\n      const ${u} start = ${u}(${$});\\n      const ${u} end = ${u}(${c});\\n\\n      void main() {\\n        ${u} outputLoc = getOutputCoords();\\n        vec4 result = vec4(0.);\\n        ${h}\\n        setOutput(result);\\n      }\\n    `}}exports.MirrorPadPackedProgram=t;"},"sourceMaps":null,"error":null,"hash":"1a0272f865da8e32cdb0c7a538f872a8","cacheData":{"env":{}}}