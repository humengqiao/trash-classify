{"id":"QOnm","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Pool3DProgram=exports.Pool2DProgram=void 0;class n{constructor(n,e,t,i=!1,a=!1){if(this.variableNames=[\"x\"],\"avg\"===e&&t)throw new Error(\"Cannot compute positions for average pool.\");const o=n.filterWidth,x=n.strideHeight,r=n.strideWidth,c=n.dilationHeight,l=n.dilationWidth,u=n.effectiveFilterHeight,s=n.effectiveFilterWidth,C=n.padInfo.top,d=n.padInfo.left;this.outputShape=n.outShape;const $=\"avg\"===e,h=`((batch  * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + d`,v=`(xR * ${n.inWidth} + xC) * ${n.inChannels} + d`;let f=\"0.0\";if($||(f=\"-1.0 / 1e-20\"),t){const e=\">=\";return void(this.userCode=`\\n        const ivec2 strides = ivec2(${x}, ${r});\\n        const ivec2 pads = ivec2(${C}, ${d});\\n\\n        void main() {\\n          ivec4 coords = getOutputCoords();\\n          int batch = coords[0];\\n          int d = coords[3];\\n\\n          ivec2 xRCCorner = coords.yz * strides - pads;\\n          int xRCorner = xRCCorner.x;\\n          int xCCorner = xRCCorner.y;\\n\\n          // max/min x(?, ?, d) to get y(yR, yC, d).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n          float avgValue = 0.0;\\n\\n          for (int wR = 0; wR < ${u};\\n              wR += ${c}) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= ${n.inHeight}) {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < ${s};\\n                wC += ${l}) {\\n              int xC = xCCorner + wC;\\n\\n              if (xC < 0 || xC >= ${n.inWidth}) {\\n                continue;\\n              }\\n\\n              float value = getX(batch, xR, xC, d);\\n\\n              // If a min / max value has already been found, use it. If not,\\n              // use the current value.\\n              float currMinMaxValue = mix(\\n                  value, minMaxValue, minMaxValueFound);\\n              if (value ${e} currMinMaxValue) {\\n                minMaxValue = value;\\n                minMaxValueFound = 1.0;\\n                minMaxPosition = ${i?a?h:v:`wR * ${s} + wC`};\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      `)}let R=`${e}(${e}(${e}(`+\"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"avg\"===e&&(R=\"avgValue / count\");const V=4*Math.floor(o/4),g=o%4,m=`\\n      if (${$}) {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    `;this.userCode=`\\n      const ivec2 strides = ivec2(${x}, ${r});\\n      const ivec2 pads = ivec2(${C}, ${d});\\n      const float initializationValue = ${f};\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xR, int xC, int d) {\\n        if (xC < 0 || xC >= ${n.inWidth}) {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xR, xC, d);\\n      }\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d = coords[3];\\n\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // max/min x(?, ?, d) to get y(yR, yC, d).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(${f});\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wR = 0; wR < ${u};\\n            wR += ${c}) {\\n          int xR = xRCorner + wR;\\n\\n          if (xR < 0 || xR >= ${n.inHeight}) {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < ${V}; wC += 4) {\\n            int xC = xCCorner + wC * ${l};\\n\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + ${l}, d),\\n              getValue(batch, xR, xC + 2 * ${l}, d),\\n              getValue(batch, xR, xC + 3 * ${l}, d)\\n            );\\n\\n            ${m}\\n          }\\n\\n          int xC = xCCorner + ${V};\\n          if (${1===g}) {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              initializationValue,\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            ${m}\\n          } else if (${2===g}) {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + ${l}, d),\\n              initializationValue,\\n              initializationValue\\n            );\\n\\n            ${m}\\n          } else if (${3===g}) {\\n            vec4 values = vec4(\\n              getValue(batch, xR, xC, d),\\n              getValue(batch, xR, xC + ${l}, d),\\n              getValue(batch, xR, xC + 2 * ${l}, d),\\n              initializationValue\\n            );\\n\\n            ${m}\\n          }\\n        }\\n        setOutput(${R});\\n      }\\n    `}}exports.Pool2DProgram=n;class e{constructor(n,e,t,i=!1,a=!1){if(this.variableNames=[\"x\"],\"avg\"===e&&t)throw new Error(\"Cannot compute positions for average pool.\");const o=n.filterWidth,x=n.strideDepth,r=n.strideHeight,c=n.strideWidth,l=n.dilationDepth,u=n.dilationHeight,s=n.dilationWidth,C=n.effectiveFilterDepth,d=n.effectiveFilterHeight,$=n.effectiveFilterWidth,h=n.padInfo.front,v=n.padInfo.top,f=n.padInfo.left;this.outputShape=n.outShape;const R=\"avg\"===e;let V=\"0.0\";if(R||(V=\"-1.0 / 1e-20\"),t){const e=\">=\";return void(this.userCode=`\\n        const ivec3 strides =\\n            ivec3(${x}, ${r}, ${c});\\n        const ivec3 pads = ivec3(${h}, ${v}, ${f});\\n\\n        void main() {\\n          ivec5 coords = getOutputCoords();\\n          int batch = coords.x;\\n          int ch = coords.u;\\n\\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n          int xDCorner = xCorner.x;\\n          int xRCorner = xCorner.y;\\n          int xCCorner = xCorner.z;\\n\\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\\n          // ? = to be determined\\n          float minMaxValue = 0.0;\\n          float minMaxValueFound = 0.0;\\n          int minMaxPosition = 0;\\n\\n          for (int wD = 0; wD < ${C};\\n              wD += ${l}) {\\n            int xD = xDCorner + wD;\\n\\n            if (xD < 0 || xD >= ${n.inDepth}) {\\n              continue;\\n            }\\n\\n            for (int wR = 0; wR < ${d};\\n                wR += ${u}) {\\n              int xR = xRCorner + wR;\\n\\n              if (xR < 0 || xR >= ${n.inHeight}) {\\n                continue;\\n              }\\n\\n              for (int wC = 0; wC < ${$};\\n                  wC += ${s}) {\\n                int xC = xCCorner + wC;\\n\\n                if (xC < 0 || xC >= ${n.inWidth}) {\\n                  continue;\\n                }\\n\\n                float value = getX(batch, xD, xR, xC, ch);\\n\\n                // If a min / max value has already been found, use it. If not,\\n                // use the current value.\\n                float currMinMaxValue = mix(\\n                    value, minMaxValue, minMaxValueFound);\\n                if (value ${e} currMinMaxValue) {\\n                  minMaxValue = value;\\n                  minMaxValueFound = 1.0;\\n                  minMaxPosition = ${i?a?`(((batch * ${n.inDepth} + xD) * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`((xD * ${n.inHeight} + xR) * ${n.inWidth} + xC) * ${n.inChannels} + ch`:`wD * ${d} * ${$} +\\n                      wR * ${$} + wC`};\\n                }\\n              }\\n            }\\n          }\\n          setOutput(float(minMaxPosition));\\n        }\\n      `)}let g=`${e}(${e}(${e}(`+\"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"avg\"===e&&(g=\"avgValue / count\");const m=4*Math.floor(o/4),w=o%4,p=`\\n      if (${R}) {\\n        avgValue += dot(values, ones);\\n      } else {\\n        minMaxValue = max(values, minMaxValue);\\n      }\\n    `;this.userCode=`\\n      const ivec3 strides =\\n        ivec3(${x}, ${r}, ${c});\\n      const ivec3 pads = ivec3(${h}, ${v}, ${f});\\n      const float initializationValue = ${V};\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float count = 0.0;\\n\\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\\n        if (xC < 0 || xC >= ${n.inWidth}) {\\n          return initializationValue;\\n        }\\n        count += 1.0;\\n        return getX(batch, xD, xR, xC, ch);\\n      }\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int ch = coords.u;\\n\\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xDCorner = xCorner.x;\\n        int xRCorner = xCorner.y;\\n        int xCCorner = xCorner.z;\\n\\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\\n        // ? = to be determined\\n        vec4 minMaxValue = vec4(${V});\\n        float avgValue = 0.0;\\n        count = 0.0;\\n\\n        for (int wD = 0; wD < ${C};\\n            wD += ${l}) {\\n          int xD = xDCorner + wD;\\n\\n          if (xD < 0 || xD >= ${n.inDepth}) {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < ${d};\\n            wR += ${u}) {\\n            int xR = xRCorner + wR;\\n\\n            if (xR < 0 || xR >= ${n.inHeight}) {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < ${m}; wC += 4) {\\n              int xC = xCCorner + wC * ${s};\\n\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + ${s}, ch),\\n                getValue(batch, xD, xR, xC + 2 * ${s}, ch),\\n                getValue(batch, xD, xR, xC + 3 * ${s}, ch)\\n              );\\n\\n              ${p}\\n            }\\n\\n            int xC = xCCorner + ${m};\\n            if (${1===w}) {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                initializationValue,\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              ${p}\\n            } else if (${2===w}) {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + ${s}, ch),\\n                initializationValue,\\n                initializationValue\\n              );\\n\\n              ${p}\\n            } else if (${3===w}) {\\n              vec4 values = vec4(\\n                getValue(batch, xD, xR, xC, ch),\\n                getValue(batch, xD, xR, xC + ${s}, ch),\\n                getValue(batch, xD, xR, xC + 2 * ${s}, ch),\\n                initializationValue\\n              );\\n\\n              ${p}\\n            }\\n          }\\n          setOutput(${g});\\n        }\\n      }\\n    `}}exports.Pool3DProgram=e;"},"sourceMaps":null,"error":null,"hash":"3672a26269b3a34e5da66de2827411ca","cacheData":{"env":{}}}