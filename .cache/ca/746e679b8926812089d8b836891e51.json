{"id":"vqcE","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":23},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"../../executor/tensor_array","loc":{"line":18,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_array.js"},{"name":"../../executor/tensor_list","loc":{"line":19,"column":52},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/executor/tensor_list.js"},{"name":"./utils","loc":{"line":20,"column":54},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/control_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/utils.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.CATEGORY=exports.executeOp=void 0;var e=require(\"@tensorflow/tfjs-core\"),a=require(\"../../executor/tensor_array\"),r=require(\"../../executor/tensor_list\"),t=require(\"./utils\");const n=async(n,s,o)=>{switch(n.op){case\"If\":case\"StatelessIf\":{const e=(0,t.getParamValue)(\"thenBranch\",n,s,o),a=(0,t.getParamValue)(\"elseBranch\",n,s,o),r=(0,t.getParamValue)(\"cond\",n,s,o),i=(0,t.getParamValue)(\"args\",n,s,o);return(await r.data())[0]?o.functionMap[e].executeFunctionAsync(i,o.tensorArrayMap,o.tensorListMap):o.functionMap[a].executeFunctionAsync(i,o.tensorArrayMap,o.tensorListMap)}case\"While\":case\"StatelessWhile\":{const e=(0,t.getParamValue)(\"body\",n,s,o),a=(0,t.getParamValue)(\"cond\",n,s,o),r=(0,t.getParamValue)(\"args\",n,s,o),i=await o.functionMap[a].executeFunctionAsync(r,o.tensorArrayMap,o.tensorListMap),u=r.map(e=>e.id);let c=await i[0].data();i.forEach(e=>{e.kept||-1!==u.indexOf(e.id)||e.dispose()});let l=r;for(;c[0];){const r=l,t=(l=await o.functionMap[e].executeFunctionAsync(l,o.tensorArrayMap,o.tensorListMap)).map(e=>e.id);r.forEach(e=>{e.kept||-1!==u.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()});const n=await o.functionMap[a].executeFunctionAsync(l,o.tensorArrayMap,o.tensorListMap);c=await n[0].data(),n.forEach(e=>{e.kept||-1!==u.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()})}return l}case\"LoopCond\":{const e=(0,t.getParamValue)(\"pred\",n,s,o);return[(0,t.cloneTensor)(e)]}case\"Switch\":{const e=(0,t.getParamValue)(\"pred\",n,s,o);let a=(0,t.getParamValue)(\"data\",n,s,o);return a.kept||(a=(0,t.cloneTensor)(a)),(await e.data())[0]?[void 0,a]:[a,void 0]}case\"Merge\":{const e=n.inputNames.find(e=>void 0!==(0,t.getTensor)(e,s,o));if(e){const a=(0,t.getTensor)(e,s,o);return[(0,t.cloneTensor)(a)]}return}case\"Enter\":{const e=(0,t.getParamValue)(\"frameName\",n,s,o),a=(0,t.getParamValue)(\"tensor\",n,s,o);return o.enterFrame(e),[(0,t.cloneTensor)(a)]}case\"Exit\":{const e=(0,t.getParamValue)(\"tensor\",n,s,o);return o.exitFrame(),[(0,t.cloneTensor)(e)]}case\"NextIteration\":{const e=(0,t.getParamValue)(\"tensor\",n,s,o);return o.nextIteration(),[(0,t.cloneTensor)(e)]}case\"TensorArrayV3\":{const r=(0,t.getParamValue)(\"size\",n,s,o),i=(0,t.getParamValue)(\"dtype\",n,s,o),u=(0,t.getParamValue)(\"elementShape\",n,s,o),c=(0,t.getParamValue)(\"dynamicSize\",n,s,o),l=(0,t.getParamValue)(\"clearAfterRead\",n,s,o),m=(0,t.getParamValue)(\"identicalElementShapes\",n,s,o),d=(0,t.getParamValue)(\"name\",n,s,o),g=new a.TensorArray(d,i,r,u,m,c,l);return o.addTensorArray(g),[g.idTensor,(0,e.scalar)(1)]}case\"TensorArrayWriteV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=(0,t.getParamValue)(\"index\",n,s,o),r=(0,t.getParamValue)(\"tensor\",n,s,o),i=o.getTensorArray(e.id);return i.write(a,r),[i.idTensor]}case\"TensorArrayReadV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=(0,t.getParamValue)(\"index\",n,s,o);return[o.getTensorArray(e.id).read(a)]}case\"TensorArrayGatherV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=(0,t.getParamValue)(\"indices\",n,s,o),r=(0,t.getParamValue)(\"dtype\",n,s,o);return[o.getTensorArray(e.id).gather(a,r)]}case\"TensorArrayScatterV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=(0,t.getParamValue)(\"indices\",n,s,o),r=(0,t.getParamValue)(\"tensor\",n,s,o),i=o.getTensorArray(e.id);return i.scatter(a,r),[i.idTensor]}case\"TensorArrayConcatV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=o.getTensorArray(e.id),r=(0,t.getParamValue)(\"dtype\",n,s,o);return[a.concat(r)]}case\"TensorArraySplitV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=(0,t.getParamValue)(\"tensor\",n,s,o),r=(0,t.getParamValue)(\"lengths\",n,s,o),i=o.getTensorArray(e.id);return i.split(r,a),[i.idTensor]}case\"TensorArraySizeV3\":{const a=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),r=o.getTensorArray(a.id);return[(0,e.scalar)(r.size(),\"int32\")]}case\"TensorArrayCloseV3\":{const e=(0,t.getParamValue)(\"tensorArrayId\",n,s,o),a=o.getTensorArray(e.id);return a.clearAndClose(),[a.idTensor]}case\"TensorListSetItem\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=(0,t.getParamValue)(\"index\",n,s,o),r=(0,t.getParamValue)(\"tensor\",n,s,o),i=o.getTensorList(e.id);return i.setItem(a,r),[i.idTensor]}case\"TensorListGetItem\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=(0,t.getParamValue)(\"index\",n,s,o),r=(0,t.getParamValue)(\"elementShape\",n,s,o),i=(0,t.getParamValue)(\"elementDType\",n,s,o);return[o.getTensorList(e.id).getItem(a,r,i)]}case\"TensorListScatterV2\":case\"TensorListScatter\":{const e=(0,t.getParamValue)(\"indices\",n,s,o),a=(0,t.getParamValue)(\"tensor\",n,s,o),i=(0,t.getParamValue)(\"elementShape\",n,s,o),u=(0,t.getParamValue)(\"numElements\",n,s,o),c=(0,r.scatter)(a,e,i,u);return o.addTensorList(c),[c.idTensor]}case\"TensorListReserve\":{const e=(0,t.getParamValue)(\"elementShape\",n,s,o),a=(0,t.getParamValue)(\"elementDType\",n,s,o),i=(0,t.getParamValue)(\"numElements\",n,s,o),u=(0,r.reserve)(e,a,i);return o.addTensorList(u),[u.idTensor]}case\"TensorListGather\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=(0,t.getParamValue)(\"indices\",n,s,o),r=(0,t.getParamValue)(\"elementShape\",n,s,o),i=(0,t.getParamValue)(\"elementDType\",n,s,o);return[o.getTensorList(e.id).gather(a,i,r)]}case\"TensorListStack\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=(0,t.getParamValue)(\"elementShape\",n,s,o),r=(0,t.getParamValue)(\"elementDType\",n,s,o),i=(0,t.getParamValue)(\"numElements\",n,s,o);return[o.getTensorList(e.id).stack(a,r,i)]}case\"TensorListFromTensor\":{const e=(0,t.getParamValue)(\"tensor\",n,s,o),a=(0,t.getParamValue)(\"elementShape\",n,s,o),i=(0,t.getParamValue)(\"elementDType\",n,s,o),u=(0,r.fromTensor)(e,a,i);return o.addTensorList(u),[u.idTensor]}case\"TensorListConcat\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=o.getTensorList(e.id),r=(0,t.getParamValue)(\"dtype\",n,s,o),i=(0,t.getParamValue)(\"elementShape\",n,s,o);return[a.concat(r,i)]}case\"TensorListPushBack\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=(0,t.getParamValue)(\"tensor\",n,s,o),r=o.getTensorList(e.id);return r.pushBack(a),[r.idTensor]}case\"TensorListPopBack\":{const e=(0,t.getParamValue)(\"tensorListId\",n,s,o),a=(0,t.getParamValue)(\"elementShape\",n,s,o),r=(0,t.getParamValue)(\"elementDType\",n,s,o);return[o.getTensorList(e.id).popBack(a,r)]}case\"TensorListSplit\":{const e=(0,t.getParamValue)(\"tensor\",n,s,o),a=(0,t.getParamValue)(\"elementShape\",n,s,o),i=(0,t.getParamValue)(\"lengths\",n,s,o),u=(0,r.split)(e,i,a);return o.addTensorList(u),[u.idTensor]}default:throw TypeError(`Node type ${n.op} is not implemented`)}};exports.executeOp=n;const s=\"control\";exports.CATEGORY=s;"},"sourceMaps":null,"error":null,"hash":"69288f92135d6fcb8b682f8d7422fb4e","cacheData":{"env":{}}}