{"id":"gzgT","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":21},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"./packing_util","loc":{"line":18,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/packing_util.js"},{"name":"./shader_compiler","loc":{"line":19,"column":34},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/argminmax_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.ArgMinMaxPackedProgram=void 0;var e=require(\"@tensorflow/tfjs-core\"),n=require(\"./packing_util\"),t=require(\"./shader_compiler\");class c{constructor(c,o,s,a){this.variableNames=[\"A\"],this.packedInputs=!0,this.packedOutput=!0,e.util.assert(c.length>2,()=>`Packed arg${s.charAt(0).toUpperCase()+s.slice(1)} supports only inputs with rank above 2.`);const i=c[c.length-1],r=Math.ceil(i/o);this.outputShape=c.slice(0,-1),r>1&&this.outputShape.push(r),a||this.variableNames.push(\"bestIndicesA\");const d=this.outputShape,l=d.length,$=(0,t.getCoordsDataType)(l),u=(0,n.getChannels)(\"coords\",l);let h,p;if(1===r){p=l+1;const e=(0,t.getCoordsDataType)(p);h=`\\n        ${e} sourceLocR = ${e}(${u.join()}, 0);\\n        ++${u[l-1]};\\n        ${e} sourceLocG = ${e}(${u.join()}, 0);\\n        ++${u[l-2]};\\n        ${e} sourceLocA = ${e}(${u.join()}, 0);\\n        --${u[l-1]};\\n        ${e} sourceLocB = ${e}(${u.join()}, 0);\\n        --${u[l-2]};`}else p=l,h=`\\n        ${$} sourceLocR = coords;\\n        ++${u[l-1]};\\n        ${$} sourceLocG = coords;\\n        ++${u[l-2]};\\n        ${$} sourceLocA = coords;\\n        --${u[l-1]};\\n        ${$} sourceLocB = coords;\\n        --${u[l-2]};`;const x=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"].slice(0,p),g=\".\"+x[p-1],v=x.map(e=>\"int \"+e),C=(0,n.getChannels)(\"sourceLocR\",p-1).concat(\"inIdx.r\"),I=(0,n.getChannels)(\"sourceLocG\",p-1).concat(\"inIdx.g\"),b=(0,n.getChannels)(\"sourceLocB\",p-1).concat(\"inIdx.b\"),A=(0,n.getChannels)(\"sourceLocA\",p-1).concat(\"inIdx.a\"),j=\"max\"===s?\"greaterThan\":\"lessThan\",L=a?\"\":`\\n          inIdx = round(vec4(getBestIndicesAChannel(${C.join()}),\\n                             getBestIndicesAChannel(${I.join()}),\\n                             getBestIndicesAChannel(${b.join()}),\\n                             getBestIndicesAChannel(${A.join()})));`,B=`vec4(\\n            getAChannel(${C.join()}),\\n            hasNextCol ? getAChannel(${I.join()}) : 0.,\\n            hasNextRow ? getAChannel(${b.join()}) : 0.,\\n            hasNextRow && hasNextCol ? getAChannel(${A.join()}) : 0.)`,m=a?\"\":`\\n      float getBestIndicesAChannel(${v.join()}) {\\n        return getChannel(getBestIndicesA(${x.join()}),\\n                                          vec2(${x.slice(-2).join()}));\\n      }`;this.userCode=`\\n      float getAChannel(${v.join()}) {\\n        return getChannel(getA(${x.join()}),\\n                               vec2(${x.slice(-2).join()}));\\n      }\\n      ${m}\\n      void main() {\\n        ${$} coords = getOutputCoords();\\n        bool hasNextCol = ${u[l-1]} < ${d[l-1]-1};\\n        bool hasNextRow = ${u[l-2]} < ${d[l-2]-1};\\n        ${h}\\n        ivec4 srcIdx = ivec4(sourceLocR${g}, sourceLocG${g},\\n          sourceLocB${g}, sourceLocA${g}) * ${o};\\n        ivec4 inIdx = srcIdx;\\n        vec4 bestIndex = vec4(inIdx);\\n        vec4 bestValue = ${B};\\n\\n        for (int i = 0; i < ${o}; i++) {\\n          inIdx = srcIdx;\\n          ${L}\\n          vec4 candidate = ${B};\\n          bvec4 nan = isnan(candidate);\\n          bvec4 replace = bvec4(\\n            vec4(${j}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\\n\\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\\n                           replace.y  ? candidate.y : bestValue.y,\\n                           replace.z  ? candidate.z : bestValue.z,\\n                           replace.w  ? candidate.w : bestValue.w);\\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\\n          srcIdx++;\\n        }\\n        setOutput(bestIndex);\\n      }\\n    `}}exports.ArgMinMaxPackedProgram=c;"},"sourceMaps":null,"error":null,"hash":"06a7258371351d615cce46cb665dc4c7","cacheData":{"env":{}}}