{"id":"CK3x","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":29},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/unaryop_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.STEP=l,exports.CLONE=exports.LOGICAL_NOT=exports.RECIPROCAL=exports.ERF=exports.ATANH=exports.ACOSH=exports.ASINH=exports.TANH=exports.COSH=exports.SINH=exports.ATAN=exports.ACOS=exports.ASIN=exports.SOFTPLUS=exports.SIGMOID=exports.RSQRT=exports.SQRT=exports.LOG1P=exports.LOG=exports.EXPM1=exports.EXP=exports.ROUND=exports.IS_FINITE=exports.IS_INF=exports.IS_NAN=exports.SIGN=exports.FLOOR=exports.CEIL=exports.NEG=exports.SELU=exports.ELU=exports.RELU6=exports.RELU=exports.ABS=exports.LINEAR=exports.UnaryOpProgram=void 0;var t=require(\"@tensorflow/tfjs-core\");class n{constructor(t,n){this.variableNames=[\"A\"],this.outputShape=t,this.userCode=`\\n      float unaryOperation(float x) {\\n        ${n}\\n      }\\n\\n      void main() {\\n        float x = getAAtOutCoords();\\n        float y = unaryOperation(x);\\n\\n        setOutput(y);\\n      }\\n    `}}exports.UnaryOpProgram=n;const e=\"if (isnan(x)) return x;\",r=\"return x;\";exports.LINEAR=r;const o=\"return abs(x);\";exports.ABS=o;const s=e+\"\\n  return (x < 0.0) ? 0.0 : x;\\n\";exports.RELU=s;const x=e+\"\\n  return (x < 0.0) ? 0.0 : min(6.0, x);\\n\";exports.RELU6=x;const a=\"return (x >= 0.0) ? x : (exp(x) - 1.0);\";exports.ELU=a;const p=`\\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\\n  // see: https://arxiv.org/abs/1706.02515\\n  float scaleAlpha = ${t.backend_util.SELU_SCALEALPHA};\\n  float scale = ${t.backend_util.SELU_SCALE};\\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\\n`;function l(t=0){return e+`\\n    return x > 0.0 ? 1.0 : float(${t});\\n  `}exports.SELU=p;const u=\"return -x;\";exports.NEG=u;const i=\"return ceil(x);\";exports.CEIL=i;const c=\"return floor(x);\";exports.FLOOR=c;const f=\"\\n  if (isnan(x)) { return 0.0; }\\n  return sign(x);\\n\";exports.SIGN=f;const A=\"return float(isnan(x));\";exports.IS_NAN=A;const N=\"return float(isinf(x));\";exports.IS_INF=N;const S=\"return float(!isnan(x) && !isinf(x));\";exports.IS_FINITE=S;const E=\"\\n  // OpenGL ES does not support round function.\\n  // The algorithm is based on banker's rounding.\\n  float base = floor(x);\\n  if ((x - base) < 0.5) {\\n    return floor(x);\\n  } else if ((x - base) > 0.5) {\\n    return ceil(x);\\n  } else {\\n    if (mod(base, 2.0) == 0.0) {\\n      return base;\\n    } else {\\n      return base + 1.0;\\n    }\\n  }\\n\";exports.ROUND=E;const O=\"return exp(x);\";exports.EXP=O;const L=\"return exp(x) - 1.0;\";exports.EXPM1=L;const _=\"if (x < 0.0) return NAN;\\n  return log(x);\";exports.LOG=_;const I=\"return log(1.0 + x);\";exports.LOG1P=I;const b=\"return sqrt(x);\";exports.SQRT=b;const d=\"return inversesqrt(x);\";exports.RSQRT=d;const R=\"return 1.0 / (1.0 + exp(-1.0 * x));\";exports.SIGMOID=R;const g=\"\\n  float epsilon = 1.1920928955078125e-7;\\n  float threshold = log(epsilon) + 2.0;\\n\\n  bool too_large = x > -threshold;\\n  bool too_small = x < threshold;\\n\\n  float result;\\n  float exp_x = exp(x);\\n\\n  if (too_large){\\n    result = x;\\n  }\\n  else if (too_small){\\n    result = exp_x;\\n  }\\n  else{\\n    result = log(exp_x + 1.0);\\n  }\\n  return result;\\n\";exports.SOFTPLUS=g;const h=e+\"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return asin(x);\\n\";exports.ASIN=h;const C=e+\"\\n  if (abs(x) > 1.) {\\n    return NAN;\\n  }\\n  return acos(x);\\n\";exports.ACOS=C;const F=e+\"\\n  return atan(x);\\n\";exports.ATAN=F;const T=\"\\n  float e2x = exp(x);\\n  return (e2x - 1.0 / e2x) / 2.0;\\n\";exports.SINH=T;const P=\"\\n  float e2x = exp(-x);\\n  return (e2x + 1.0 / e2x) / 2.0;\\n\";exports.COSH=P;const m=\"\\n  float e2x = exp(-2.0 * abs(x));\\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\\n\";exports.TANH=m;const U=e+\"return log(x + sqrt(x * x + 1.0));\";exports.ASINH=U;const G=e+\"\\n  if (x < 1.0) return NAN;\\n  return log(x + sqrt(x * x - 1.0));\";exports.ACOSH=G;const H=e+\"\\n  if ((x < -1.0) || (x > 1.0)) return NAN;\\n  return (log(1.0 + x) - log(1.0 - x)) / 2.0;\";exports.ATANH=H;const k=`\\n  // Error function is calculated approximately with elementary function.\\n  // See \"Handbook of Mathematical Functions with Formulas,\\n  // Graphs, and Mathematical Tables\", Abramowitz and Stegun.\\n  float p = ${t.backend_util.ERF_P};\\n  float a1 = ${t.backend_util.ERF_A1};\\n  float a2 = ${t.backend_util.ERF_A2};\\n  float a3 = ${t.backend_util.ERF_A3};\\n  float a4 = ${t.backend_util.ERF_A4};\\n  float a5 = ${t.backend_util.ERF_A5};\\n\\n  float sign = sign(x);\\n  x = abs(x);\\n  float t = 1.0 / (1.0 + p * x);\\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\\n`;exports.ERF=k;const $=\"return 1.0 / x;\";exports.RECIPROCAL=$;const y=\"return float(!(x >= 1.0));\";exports.LOGICAL_NOT=y;const v=\"return x;\";exports.CLONE=v;"},"sourceMaps":null,"error":null,"hash":"5a80f963e09f639ad6925df3380f42e0","cacheData":{"env":{}}}