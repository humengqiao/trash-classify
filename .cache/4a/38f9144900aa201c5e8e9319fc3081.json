{"id":"s3KE","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":21},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/conv_packed_gpu_depthwise.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.DepthwiseConvPacked2DProgram=void 0;var e=require(\"@tensorflow/tfjs-core\");class n{constructor(n,x=!1,t=null,$=!1){this.variableNames=[\"x\",\"W\"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.outShape;const C=n.inHeight,s=n.inWidth,f=n.padInfo.top,i=n.padInfo.left,c=n.strideHeight,l=n.strideWidth,R=n.dilationHeight,r=n.dilationWidth,o=n.filterHeight,a=n.filterWidth,v=a;let d=\"int xR; int xC; int xCOffset;\";for(let e=0;e<o;e++)for(let n=0;n<a;n++)d+=`\\n          vec4 xTexelR${e}C${2*n} = vec4(0.);\\n          vec4 wR${e}C${n} = vec4(0.);\\n          vec4 xR${e}C${n} = vec4(0.);`;for(let T=0;T<o;T++)for(let n=0;n<v;n++){const x=2*n;if(d+=`\\n          xR = xRCorner + ${T*R};\\n          xC = xCCorner + ${x*r};\\n        `,1===l){if(x<a&&(d+=i%2==1?`\\n                xCOffset = xC + 1;\\n                if(xR >= 0 && xR < ${C} && xCOffset >= 0 && xCOffset < ${s}) {\\n                  xTexelR${T}C${x} = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= ${s}) {\\n                    xTexelR${T}C${x}.zw = vec2(0.);\\n                  }\\n                } else {\\n                  xTexelR${T}C${x} = vec4(0.);\\n                }\\n\\n                xCOffset = xC + 1 - 2;\\n                if(xR >= 0 && xR < ${C} && xCOffset >= 0 && xCOffset < ${s}) {\\n                  vec4 previous = getX(batch, xR, xCOffset, d1);\\n\\n                  // Need to manually clear unused channels in case\\n                  // we're reading from recycled texture.\\n                  if(xCOffset + 1 >= ${s}) {\\n                    previous.zw = vec2(0.);\\n                  }\\n\\n                  xR${T}C${x} = vec4(previous.zw, xTexelR${T}C${x}.xy);\\n                } else {\\n                  xR${T}C${x} = vec4(0, 0, xTexelR${T}C${x}.xy);\\n                }\\n              `:`\\n                if(xR >= 0 && xR < ${C} && xC >= 0 && xC < ${s}) {\\n                  xTexelR${T}C${x} = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR${T}C${x} = vec4(0.);\\n                }\\n\\n                xR${T}C${x} = xTexelR${T}C${x};\\n              `,x+1<a)){const n=i%2==0?e.util.nearestLargerEven(r):r;r%2==0&&i%2==1||r%2!=0&&i%2!=1?(d+=`\\n                  xCOffset = xC + ${i%2} + ${n};\\n\\n                  if(xR >= 0 && xR < ${C} &&\\n                    xCOffset >= 0 && xCOffset < ${s}) {\\n                    xTexelR${T}C${x+2} = getX(batch, xR, xCOffset, d1);\\n                  }\\n                `,r>1&&(d+=`\\n                    xCOffset -= 2;\\n                    if(xR >= 0 && xR < ${C} &&\\n                      xCOffset >= 0 && xCOffset < ${s}) {\\n                      xTexelR${T}C${x} = getX(batch, xR, xCOffset, d1);\\n                    } else {\\n                      xTexelR${T}C${x} = vec4(0.);\\n                    }\\n                  `),d+=`\\n                  xR${T}C${x+1} = vec4(\\n                    xTexelR${T}C${x}.zw, xTexelR${T}C${x+2}.xy);\\n                `):d+=`\\n                  xCOffset = xC + ${n};\\n\\n                  if(xR >= 0 && xR < ${C} &&\\n                    xCOffset >= 0 && xCOffset < ${s}) {\\n                    xTexelR${T}C${x+2} = getX(batch, xR, xCOffset, d1);\\n                  }\\n\\n                  xR${T}C${x+1} = xTexelR${T}C${x+2};\\n                `}}else x<a&&(d+=`\\n              if(xR >= 0 && xR < ${C}) {\\n            `,i%2==1?(d+=`\\n                xCOffset = xC + 1 - ${l};\\n                if(xCOffset >= 0 && xCOffset < ${s}) {\\n                  xTexelR${T}C${x} = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR${T}C${x} = vec4(0.);\\n                }\\n\\n                if(xC + 1 >= 0 && xC + 1 < ${s}) {\\n                  xTexelR${T}C${x+2} = getX(batch, xR, xC + 1, d1);\\n                } else {\\n                  xTexelR${T}C${x+2} = vec4(0.);\\n                }\\n\\n                xR${T}C${x} = vec4(\\n                  xTexelR${T}C${x}.zw, xTexelR${T}C${x+2}.zw);\\n              `,x+1<a&&(d+=`\\n                  vec4 final = vec4(0.);\\n                  xCOffset = xC + 1 + ${l};\\n                  if(xCOffset >= 0 && xCOffset < ${s}) {\\n                    final = getX(batch, xR, xCOffset, d1);\\n                  }\\n                  xR${T}C${x+1} = vec4(xTexelR${T}C${x+2}.xy, final.xy);\\n                `)):(d+=`\\n                if(xC >= 0 && xC < ${s}) {\\n                  xTexelR${T}C${x} = getX(batch, xR, xC, d1);\\n                } else {\\n                  xTexelR${T}C${x} = vec4(0.);\\n                }\\n\\n                xCOffset = xC + ${l};\\n                if(xCOffset >= 0 && xCOffset < ${s}) {\\n                  xTexelR${T}C${x+2} = getX(batch, xR, xCOffset, d1);\\n                } else {\\n                  xTexelR${T}C${x+2} = vec4(0.);\\n                }\\n\\n                xR${T}C${x} = vec4(\\n                  xTexelR${T}C${x}.xy, xTexelR${T}C${x+2}.xy);\\n              `,x+1<a&&(d+=`\\n                  xR${T}C${x+1} = vec4(\\n                    xTexelR${T}C${x}.zw, xTexelR${T}C${x+2}.zw);\\n                `)),d+=\"}\");x<a&&(d+=`\\n            vec4 wTexelR${T}C${x} = getW(${T}, ${x}, d1, q);\\n            wR${T}C${x} = vec4(wTexelR${T}C${x}.xz, wTexelR${T}C${x}.xz);\\n          `,x+1<a&&(d+=`\\n              vec4 wTexelR${T}C${x+1} = getW(${T}, ${x+1}, d1, q);\\n              wR${T}C${x+1} =\\n                vec4(wTexelR${T}C${x+1}.xz, wTexelR${T}C${x+1}.xz);`))}for(let e=0;e<o;e++)for(let n=0;n<a;n++)d+=`dotProd += xR${e}C${n} * wR${e}C${n};`;let O=\"\",u=\"\";t&&(O=$?`vec4 activation(vec4 a) {\\n          vec4 b = getPreluActivationWeightsAtOutCoords();\\n          ${t}\\n        }`:`vec4 activation(vec4 x) {\\n          ${t}\\n        }`,u=\"result = activation(result);\");const h=x?\"result += getBiasAtOutCoords();\":\"\";x&&this.variableNames.push(\"bias\"),$&&this.variableNames.push(\"preluActivationWeights\"),this.userCode=`\\n      ${O}\\n\\n      const ivec2 strides = ivec2(${c}, ${l});\\n      const ivec2 pads = ivec2(${f}, ${i});\\n\\n      void main() {\\n\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords.x;\\n        ivec2 xRCCorner = coords.yz * strides - pads;\\n        int d2 = coords.w;\\n        int d1 = d2;\\n        int q = 0;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        vec4 dotProd = vec4(0.);\\n\\n        ${d}\\n\\n        vec4 result = dotProd;\\n        ${h}\\n        ${u}\\n        setOutput(result);\\n      }\\n    `}}exports.DepthwiseConvPacked2DProgram=n;"},"sourceMaps":null,"error":null,"hash":"9f2841286f8804ac25c761d7c554c499","cacheData":{"env":{}}}