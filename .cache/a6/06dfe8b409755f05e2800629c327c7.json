{"id":"GBM9","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":11,"column":49},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"./backend/state","loc":{"line":12,"column":23},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/backend/state.js"},{"name":"./engine/input_layer","loc":{"line":13,"column":22},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js"},{"name":"./engine/topology","loc":{"line":14,"column":38},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js"},{"name":"./engine/training","loc":{"line":15,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/training.js"},{"name":"./errors","loc":{"line":16,"column":62},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/errors.js"},{"name":"./layers/serialization","loc":{"line":17,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/serialization.js"},{"name":"./utils/generic_utils","loc":{"line":18,"column":31},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js"},{"name":"./utils/serialization_utils","loc":{"line":19,"column":36},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/serialization_utils.js"},{"name":"./utils/types_utils","loc":{"line":20,"column":35},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/models.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.modelFromJSON=p,exports.loadLayersModelInternal=m,exports.loadLayersModelFromIOHandler=c,exports.Sequential=void 0;var e=require(\"@tensorflow/tfjs-core\"),t=require(\"./backend/state\"),i=require(\"./engine/input_layer\"),s=require(\"./engine/topology\"),o=require(\"./engine/training\"),n=require(\"./errors\"),r=require(\"./layers/serialization\"),l=d(require(\"./utils/generic_utils\")),a=require(\"./utils/serialization_utils\"),u=require(\"./utils/types_utils\");function h(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return h=function(){return e},e}function d(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=h();if(t&&t.has(e))return t.get(e);var i={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var o in e)if(Object.prototype.hasOwnProperty.call(e,o)){var n=s?Object.getOwnPropertyDescriptor(e,o):null;n&&(n.get||n.set)?Object.defineProperty(i,o,n):i[o]=e[o]}return i.default=e,t&&t.set(e,i),i}async function p(t,i){\"modelTopology\"in t||(t={modelTopology:t});let s=(t=t).modelTopology;null!=s.model_config&&(s=s.model_config);const o=(0,a.convertPythonicToTs)(s),n=(0,r.deserialize)(o,i);if(null!=t.weightsManifest){const i=await e.io.loadWeights(t.weightsManifest,t.pathPrefix,n.weights.map(e=>e.originalName)),s={};for(const e of n.weights)s[e.originalName]=i[e.originalName];n.loadWeights(s),(0,e.dispose)(i)}return n}async function m(t,i){if(null==i&&(i={}),\"string\"==typeof t){const s=e.io.getLoadHandlers(t,i);if(0===s.length)s.push(e.io.browserHTTPRequest(t,i));else if(s.length>1)throw new n.ValueError(`Found more than one (${s.length}) load handlers for `+`URL '${t}'`);t=s[0]}return c(t,void 0,i)}async function c(t,i,s){if(null==s&&(s={}),null==t.load)throw new n.ValueError(\"Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.\");const o=await t.load();let l=o.modelTopology;null!=l.model_config&&(l=l.model_config);const u=null==s.strict||s.strict,h=null!=o.weightData&&null!=o.weightSpecs&&u,d=(0,r.deserialize)((0,a.convertPythonicToTs)(l),i,h),p=o.trainingConfig;if(null!=p&&d.loadTrainingConfig(p),null!=o.userDefinedMetadata&&d.setUserDefinedMetadata(o.userDefinedMetadata),null!=o.weightData){if(null==o.weightSpecs)throw new n.ValueError(\"LayersModel artifacts contains weight data, but not weight specs. Therefore loading of weights cannot proceed.\");const{modelWeights:t,optimizerWeights:i}=f(o.weightData,o.weightSpecs);d.loadWeights(t,u),null!=d.optimizer&&i.length>0&&await d.optimizer.setWeights(i),(0,e.dispose)(t),(0,e.dispose)(i.map(e=>e.tensor))}return d}function f(t,i){const s=e.io.decodeWeights(t,i),o={},n=[];return i.forEach(e=>{\"optimizer\"===e.group?n.push({name:e.name,tensor:s[e.name]}):o[e.name]=s[e.name]}),{modelWeights:o,optimizerWeights:n}}class g extends o.LayersModel{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:(0,t.getUid)(\"sequential_\"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(e=>e<0))throw new n.ValueError(\"Negative dimension size caused by adding layer \"+`${e.name} with input shape [`+`${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof g||e instanceof o.LayersModel;let r;if(t){if(1!==(r=e).outputs.length)throw new n.ValueError(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");if(1!==r.inputs.length)throw new n.ValueError(\"All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.\")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new n.ValueError(\"The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.\");const t=(0,i.Input)({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+\"_input\"});e.apply(t)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(1!==e.inboundNodes.length)throw new n.ValueError(\"A layer added to a Sequential model must not already be \"+`connected somewhere else. LayersModel received layer ${e.name} `+`which has ${e.inboundNodes.length} pre-existing inbound `+\"connections.\");if(1!==e.inboundNodes[0].outputTensors.length)throw new n.ValueError(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=(0,s.getSourceInputs)(this.outputs[0])}this.inboundNodes=[],new s.Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:l.pyListRepeat(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(e=>e.shape),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError(\"All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.\");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError(\"There are no layers in the model.\");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if((0,u.getExactlyOneShape)(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError(\"Sequential model cannot be built: model is empty. Add some layers first.\");this.model=new o.LayersModel({inputs:this.inputs,outputs:this.outputs[0],name:this.name+\"_model\"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,i=console.log){this.built||this.build(),super.summary(e,t,i)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t,i={}){if(!this.built)throw new n.RuntimeError(\"The model needs to be compiled before being used.\");return this.model.evaluate(e,t,i)}async evaluateDataset(e,t){if(!this.built)throw new n.RuntimeError(\"The model needs to be compiled before being used.\");return this.model.evaluateDataset(e,t)}predict(e,t={}){return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,i={}){if(!this.built)throw new n.RuntimeError(\"The model needs to be compiled before being used.\");return this.model.fit(e,t,i)}async fitDataset(e,t){if(!this.built)throw new n.RuntimeError(\"The model needs to be compiled before being used.\");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(t,i,s={},o=!1){let l,a={};if(i instanceof Array){if(null==i[0].className||\"Merge\"===i[0].className)throw new n.ValueError(\"Legacy serialization format not supported yet.\");l=i}else e.util.assert(null!=i.layers,()=>\"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.\"),l=i.layers,delete i.layers,a=i;const u=new t(a);if(!(u instanceof g))throw new n.NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${u}`);for(const e of l){const t=void 0,i=(0,r.deserialize)(e,t,o);o&&i.setFastWeightInitDuringBuild(!0),u.add(i)}return u}set stopTraining(e){if(null==this.model)throw new n.ValueError(\"Cannot set the stopTraining property of a sequential model before it is compiled.\");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new n.ValueError(\"Cannot get the stopTraining property of a sequential model before it is compiled.\");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const i={};i.className=t.getClassName(),i.config=t.getConfig(),e.push(i)}return{name:this.name,layers:e}}}exports.Sequential=g,g.className=\"Sequential\",e.serialization.registerClass(g);"},"sourceMaps":null,"error":null,"hash":"8e889477f4ea7388013e5ad123515e87","cacheData":{"env":{}}}