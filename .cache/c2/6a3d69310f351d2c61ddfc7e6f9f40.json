{"id":"OtYx","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609564004117},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":37},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchNorm.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"../cpu_util","loc":{"line":18,"column":33},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/kernels/BatchNorm.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.batchNorm=t,exports.batchNormConfig=void 0;var e=require(\"@tensorflow/tfjs-core\"),a=require(\"../cpu_util\");function t(t){const{inputs:n,backend:r,attrs:l}=t,{x:s,scale:o,offset:h,mean:u,variance:i}=n;e.util.assert(u.shape.length===i.shape.length,()=>\"Batch normalization gradient requires mean and variance to have equal ranks.\"),e.util.assert(null==h||u.shape.length===h.shape.length,()=>\"Batch normalization gradient requires mean and offset to have equal ranks.\"),e.util.assert(null==o||u.shape.length===o.shape.length,()=>\"Batch normalization gradient requires mean and scale to have equal ranks.\"),(0,a.assertNotComplex)([s,u,i,o,h],\"batchNorm\");let{varianceEpsilon:d}=l;null==d&&(d=.001);const c=r.data.get(s.dataId).values,g=r.data.get(u.dataId).values,p=r.data.get(i.dataId).values,m=o?r.data.get(o.dataId).values:new Float32Array([1]),v=h?r.data.get(h.dataId).values:new Float32Array([0]),f=new Float32Array(c.length),q=v.length,k=m.length,N=p.length,b=g.length;let x=0,I=0,y=0,F=0;for(let e=0;e<c.length;++e)f[e]=v[x++]+(c[e]-g[I++])*m[y++]/Math.sqrt(p[F++]+d),x>=q&&(x=0),I>=b&&(I=0),y>=k&&(y=0),F>=N&&(F=0);return r.makeTensorInfo(s.shape,s.dtype,f)}const n={kernelName:e.FusedBatchNorm,backendName:\"cpu\",kernelFunc:t};exports.batchNormConfig=n;"},"sourceMaps":null,"error":null,"hash":"94f2548a376acda71af83d456cfc6caf","cacheData":{"env":{}}}