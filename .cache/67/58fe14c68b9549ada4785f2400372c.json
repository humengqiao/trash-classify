{"id":"dCKU","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.ReduceProgram=void 0;class n{constructor(n,e){this.variableNames=[\"x\"];const{windowSize:a,batchSize:l,inSize:t,outSize:i}=n;this.outputShape=[l,i];let u=\"0.0\",o=\"\";\"prod\"===e?u=\"1.0\":\"min\"===e?(u=\"1.0 / 1e-20\",o=\"min\"):\"max\"===e&&(u=\"-1.0 / 1e-20\",o=\"max\");let d=`${e}(${e}(${e}(`+\"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])\";\"sum\"===e?d=\"sumValue\":\"prod\"===e?d=\"prodValue\":\"all\"===e?d=\"allValue\":\"any\"===e&&(d=\"anyValue\");const s=4*Math.floor(a/4),V=a%4;let c=`\\n      if (${\"sum\"===e}) {\\n        sumValue += dot(values, ones);\\n      } else if (${\"prod\"===e}) {\\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\\n        prodValue *= tmp[0] * tmp[1];\\n      } else {\\n        minMaxValue = ${o}(values, minMaxValue);\\n      }\\n    `,r=\"vec4\";\"all\"===e?(u=\"1.0\",c=\"\\n        bool reducedAllValue = all(values);\\n        float floatedReducedAllValue = float(reducedAllValue);\\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\\n      \",r=\"bvec4\"):\"any\"===e&&(u=\"0.0\",c=\"\\n        bool reducedAnyValue = any(values);\\n        float floatedReducedAnyValue = float(reducedAnyValue);\\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\\n      \",r=\"bvec4\");let f=\"\";t%a>0&&(f=`\\n        if (inIdx < 0 || inIdx >= ${t}) {\\n          return initializationValue;\\n        }\\n      `),this.userCode=`\\n      const float initializationValue = ${u};\\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\\n\\n      float getValue(int batch, int inIdx) {\\n        ${f}\\n        return getX(batch, inIdx);\\n      }\\n\\n      void main() {\\n        ivec2 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int outIdx = coords[1];\\n        int inOffset = outIdx * ${a};\\n\\n        vec4 minMaxValue = vec4(${u});\\n        float prodValue = 1.0;\\n        float sumValue = 0.0;\\n        float allValue = 1.0;\\n        float anyValue = 0.0;\\n\\n        for (int i = 0; i < ${s}; i += 4) {\\n          int inIdx = inOffset + i;\\n          ${r} values = ${r}(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            getValue(batch, inIdx + 3)\\n          );\\n\\n          ${c}\\n        }\\n\\n        int inIdx = inOffset + ${s};\\n        if (${1===V}) {\\n          ${r} values = ${r}(\\n            getValue(batch, inIdx),\\n            initializationValue,\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          ${c}\\n        } else if (${2===V}) {\\n          ${r} values = ${r}(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            initializationValue,\\n            initializationValue\\n          );\\n\\n          ${c}\\n        } else if (${3===V}) {\\n          ${r} values = ${r}(\\n            getValue(batch, inIdx),\\n            getValue(batch, inIdx + 1),\\n            getValue(batch, inIdx + 2),\\n            initializationValue\\n          );\\n\\n          ${c}\\n        }\\n        setOutput(${d});\\n      }\\n    `}}exports.ReduceProgram=n;"},"sourceMaps":null,"error":null,"hash":"d58188d29de0ec6ed48bf2c67cc7ef49","cacheData":{"env":{}}}