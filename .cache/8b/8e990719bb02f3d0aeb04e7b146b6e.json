{"id":"J5U2","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609564004117},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Conv3DDerInputProgram=exports.Conv3DDerFilterProgram=exports.Conv2DDerInputProgram=exports.Conv2DDerFilterProgram=void 0;class n{constructor(n){this.variableNames=[\"x\",\"dy\"],this.outputShape=n.filterShape;const t=n.strideHeight,o=n.strideWidth,e=n.padInfo.top,d=n.padInfo.left,i=\"channelsLast\"===n.dataFormat;this.userCode=`\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int wR = coords.x;\\n        int wC = coords.y;\\n        int d1 = coords.z;\\n        int d2 = coords.w;\\n\\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < ${n.batchSize}; b++) {\\n          for (int yR = 0; yR < ${n.outHeight}; yR++) {\\n            int xR = wR + yR * ${t} - ${e};\\n\\n            if (xR < 0 || xR >= ${n.inHeight}) {\\n              continue;\\n            }\\n\\n            for (int yC = 0; yC < ${n.outWidth}; yC++) {\\n              int xC = wC + yC * ${o} - ${d};\\n\\n              if (xC < 0 || xC >= ${n.inWidth}) {\\n                continue;\\n              }\\n\\n              if (${i}) {\\n                float dyValue = getDy(b, yR, yC, d2);\\n                float xValue = getX(b, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              } else {\\n                float dyValue = getDy(b, d2, yR, yC);\\n                float xValue = getX(b, d1, xR, xC);\\n                dotProd += (xValue * dyValue);\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    `}}exports.Conv2DDerFilterProgram=n;class t{constructor(n){this.variableNames=[\"dy\",\"W\"],this.outputShape=n.inShape;const t=n.filterHeight,o=n.filterWidth,e=n.strideHeight,d=n.strideWidth,i=\"channelsLast\"===n.dataFormat,r=t-1-n.padInfo.top,a=o-1-n.padInfo.left,s=i?1:2,y=i?2:3,C=i?3:1;this.userCode=`\\n      const ivec2 pads = ivec2(${r}, ${a});\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d1 = coords[${C}];\\n\\n        ivec2 dyCorner = ivec2(coords[${s}], coords[${y}]) - pads;\\n        int dyRCorner = dyCorner.x;\\n        int dyCCorner = dyCorner.y;\\n\\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < ${t}; wR++) {\\n          float dyR = float(dyRCorner + wR) / ${e}.0;\\n\\n          if (dyR < 0.0 || dyR >= ${n.outHeight}.0 || fract(dyR) > 0.0) {\\n            continue;\\n          }\\n          int idyR = int(dyR);\\n\\n          int wRPerm = ${t} - 1 - wR;\\n\\n          for (int wC = 0; wC < ${o}; wC++) {\\n            float dyC = float(dyCCorner + wC) / ${d}.0;\\n\\n            if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\\n                fract(dyC) > 0.0) {\\n              continue;\\n            }\\n            int idyC = int(dyC);\\n\\n            int wCPerm = ${o} - 1 - wC;\\n\\n            for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\\n\\n              if (${i}) {\\n                float xValue = getDy(batch, idyR, idyC, d2);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              } else {\\n                float xValue = getDy(batch, d2, idyR, idyC);\\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    `}}exports.Conv2DDerInputProgram=t;class o{constructor(n){this.variableNames=[\"x\",\"dy\"],this.outputShape=n.filterShape;const t=n.strideDepth,o=n.strideHeight,e=n.strideWidth,d=n.padInfo.front,i=n.padInfo.top,r=n.padInfo.left;this.userCode=`\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int wF = coords.x;\\n        int wR = coords.y;\\n        int wC = coords.z;\\n        int d1 = coords.w;\\n        int d2 = coords.u;\\n\\n        float dotProd = 0.0;\\n\\n        for (int b = 0; b < ${n.batchSize}; b++) {\\n          for (int yF = 0; yF < ${n.outDepth}; yF++) {\\n            int xF = wF + yF * ${t} - ${d};\\n\\n            if (xF < 0 || xF >= ${n.inDepth}) {\\n              continue;\\n            }\\n\\n            for (int yR = 0; yR < ${n.outHeight}; yR++) {\\n              int xR = wR + yR * ${o} - ${i};\\n\\n              if (xR < 0 || xR >= ${n.inHeight}) {\\n                continue;\\n              }\\n\\n              for (int yC = 0; yC < ${n.outWidth}; yC++) {\\n                int xC = wC + yC * ${e} - ${r};\\n\\n                if (xC < 0 || xC >= ${n.inWidth}) {\\n                  continue;\\n                }\\n\\n                float dyValue = getDy(b, yF, yR, yC, d2);\\n                float xValue = getX(b, xF, xR, xC, d1);\\n                dotProd += (xValue * dyValue);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    `}}exports.Conv3DDerFilterProgram=o;class e{constructor(n){this.variableNames=[\"dy\",\"W\"],this.outputShape=n.inShape;const t=n.filterDepth,o=n.filterHeight,e=n.filterWidth,d=n.strideDepth,i=n.strideHeight,r=n.strideWidth,a=t-1-n.padInfo.front,s=o-1-n.padInfo.top,y=e-1-n.padInfo.left;this.userCode=`\\n      const ivec3 pads = ivec3(${a}, ${s}, ${y});\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d1 = coords.u;\\n\\n\\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\\n        int dyFCorner = dyCorner.x;\\n        int dyRCorner = dyCorner.y;\\n        int dyCCorner = dyCorner.z;\\n\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < ${t}; wF++) {\\n          float dyF = float(dyFCorner + wF) / ${d}.0;\\n\\n          if (dyF < 0.0 || dyF >= ${n.outDepth}.0 || fract(dyF) > 0.0) {\\n            continue;\\n          }\\n          int idyF = int(dyF);\\n\\n          int wFPerm = ${t} - 1 - wF;\\n\\n          for (int wR = 0; wR < ${o}; wR++) {\\n            float dyR = float(dyRCorner + wR) / ${i}.0;\\n\\n            if (dyR < 0.0 || dyR >= ${n.outHeight}.0 ||\\n              fract(dyR) > 0.0) {\\n              continue;\\n            }\\n            int idyR = int(dyR);\\n\\n            int wRPerm = ${o} - 1 - wR;\\n\\n            for (int wC = 0; wC < ${e}; wC++) {\\n              float dyC = float(dyCCorner + wC) / ${r}.0;\\n\\n              if (dyC < 0.0 || dyC >= ${n.outWidth}.0 ||\\n                  fract(dyC) > 0.0) {\\n                continue;\\n              }\\n              int idyC = int(dyC);\\n\\n              int wCPerm = ${e} - 1 - wC;\\n\\n              for (int d2 = 0; d2 < ${n.outChannels}; d2++) {\\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\\n                dotProd += xValue * wValue;\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    `}}exports.Conv3DDerInputProgram=e;"},"sourceMaps":null,"error":null,"hash":"713b41fae48897855a21b0fc293d7be4","cacheData":{"env":{}}}