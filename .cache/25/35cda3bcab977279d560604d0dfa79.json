{"id":"xdtw","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565602436},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":10,"column":30},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"../backend/state","loc":{"line":11,"column":23},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/backend/state.js"},{"name":"../errors","loc":{"line":12,"column":27},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/errors.js"},{"name":"./topology","loc":{"line":13,"column":44},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Input=p,exports.InputLayer=void 0;var e=require(\"@tensorflow/tfjs-core\"),t=require(\"../backend/state\"),n=require(\"../errors\"),a=require(\"./topology\");class s extends a.Layer{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:(0,t.getUid)(\"input\").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new n.ValueError(\"Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.\");let s=e.batchInputShape;if(null==s){if(null==e.inputShape)throw new n.ValueError(\"An InputLayer should be passed either a `batchInputShape` or an `inputShape`.\");s=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new n.ValueError(\"Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.\");const p=e.dtype||\"float32\";this.batchInputShape=s,this.dtype=p,this.inputSpec=[{shape:s}];const r=new a.SymbolicTensor(this.dtype,this.batchInputShape,this,[],{},this.name);r.nodeIndex=0,r.tensorIndex=0,new a.Node({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[r],outputTensors:[r],inputMasks:[null],outputMasks:[null],inputShapes:[s],outputShapes:[s]})}apply(e,t){throw new n.ValueError(\"Cannot pass any input to an \"+`InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}function p(e){if(null==e.batchShape&&null==e.shape)throw new Error(\"Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.\");if(null!=e.batchShape&&null!=e.shape)throw new n.ValueError(\"Please provide either a `shape` or `batchShape` argument to Input, but not both.\");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let a=e.dtype;return null==a&&(a=\"float32\"),new s({batchInputShape:t,name:e.name,dtype:a,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}exports.InputLayer=s,s.className=\"InputLayer\",e.serialization.registerClass(s);"},"sourceMaps":null,"error":null,"hash":"ab20de9f3c9fe7978bd5f46b51019d93","cacheData":{"env":{}}}