{"id":"lmh8","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565602436},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":22,"column":21},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"../backend/tfjs_backend","loc":{"line":23,"column":19},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js"},{"name":"../common","loc":{"line":24,"column":50},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/common.js"},{"name":"../engine/topology","loc":{"line":25,"column":26},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js"},{"name":"../errors","loc":{"line":26,"column":64},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/errors.js"},{"name":"../initializers","loc":{"line":27,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/initializers.js"},{"name":"../utils/conv_utils","loc":{"line":28,"column":49},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/conv_utils.js"},{"name":"../utils/generic_utils","loc":{"line":29,"column":38},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js"},{"name":"../utils/types_utils","loc":{"line":30,"column":35},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js"},{"name":"./recurrent","loc":{"line":31,"column":60},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/recurrent.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.ConvLSTM2D=exports.ConvLSTM2DCell=void 0;var t=c(require(\"@tensorflow/tfjs-core\")),e=c(require(\"../backend/tfjs_backend\")),s=require(\"../common\"),i=require(\"../engine/topology\"),r=require(\"../errors\"),n=require(\"../initializers\"),a=require(\"../utils/conv_utils\"),l=require(\"../utils/generic_utils\"),o=require(\"../utils/types_utils\"),u=require(\"./recurrent\");function h(){if(\"function\"!=typeof WeakMap)return null;var t=new WeakMap;return h=function(){return t},t}function c(t){if(t&&t.__esModule)return t;if(null===t||\"object\"!=typeof t&&\"function\"!=typeof t)return{default:t};var e=h();if(e&&e.has(t))return e.get(t);var s={},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var r in t)if(Object.prototype.hasOwnProperty.call(t,r)){var n=i?Object.getOwnPropertyDescriptor(t,r):null;n&&(n.get||n.set)?Object.defineProperty(s,r,n):s[r]=t[r]}return s.default=t,e&&e.set(t,s),s}var p=function(t,e){var s={};for(var i in t)Object.prototype.hasOwnProperty.call(t,i)&&e.indexOf(i)<0&&(s[i]=t[i]);if(null!=t&&\"function\"==typeof Object.getOwnPropertySymbols){var r=0;for(i=Object.getOwnPropertySymbols(t);r<i.length;r++)e.indexOf(i[r])<0&&Object.prototype.propertyIsEnumerable.call(t,i[r])&&(s[i[r]]=t[i[r]])}return s};class d extends u.RNNCell{}class f extends u.RNN{constructor(t){if(t.unroll)throw new r.NotImplementedError(\"Unrolling is not possible with convolutional RNNs.\");if(Array.isArray(t.cell))throw new r.NotImplementedError(\"It is not possible at the moment to stack convolutional cells.\");super(t),this.inputSpec=[new i.InputSpec({ndim:5})]}call(e,s){return t.tidy(()=>{if(null!=this.cell.dropoutMask&&(t.dispose(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(t.dispose(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),s&&s.constants)throw new r.ValueError(\"ConvRNN2D cell does not support constants\");const i=null==s?null:s.mask,n=null==s?null:s.training,a=null==s?null:s.initialState;return super.call(e,{mask:i,training:n,initialState:a})})}computeOutputShape(t){let e=this.computeSingleOutputShape(t);return this.returnSequences||(e=[e[0],...e.slice(2)]),this.returnState&&(e=[e,...Array(2).fill([t[0],...e.slice(-3)])]),e}getInitialState(e){return t.tidy(()=>{const{stateSize:s}=this.cell,i=e.shape,r=this.computeSingleOutputShape(i),n=[r[0],...r.slice(2)],a=t.zeros(n);return Array.isArray(s)?Array(s.length).fill(a):[a]})}resetStates(e,s=!1){t.tidy(()=>{if(!this.stateful)throw new r.AttributeError(\"Cannot call resetStates() on an RNN Layer that is not stateful.\");const i=this.inputSpec[0].shape,n=this.computeSingleOutputShape(i),a=[n[0],...n.slice(2)];if(null==i[0])throw new r.ValueError(\"If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \\n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.\");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>t.zeros(a)):this.states_=[t.zeros(a)];else if(null==e)t.dispose(this.states_),null!=this.keptStates&&(t.dispose(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>t.zeros(a)):this.states_[0]=t.zeros(a);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new r.ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), `+`but it received ${e.length} state value(s). Input `+`received: ${e}`);s?this.keptStates.push(this.states_.slice()):t.dispose(this.states_);for(let s=0;s<this.states_.length;++s){const i=e[s],n=a;if(!t.util.arraysEqual(i.shape,n))throw new r.ValueError(`State ${s} is incompatible with layer ${this.name}: `+`expected shape=${n}, received shape=${i.shape}`);this.states_[s]=i}}this.states_=this.states_.map(e=>t.keep(e.clone()))})}computeSingleOutputShape(t){const{dataFormat:e,filters:s,kernelSize:i,padding:r,strides:n,dilationRate:l}=this.cell,o=\"channelsFirst\"===e,u=t[o?3:2],h=t[o?4:3],c=(0,a.convOutputLength)(u,i[0],r,n[0],l[0]),p=(0,a.convOutputLength)(h,i[1],r,n[1],l[1]);return[...t.slice(0,2),...o?[s,c,p]:[c,p,s]]}}f.className=\"ConvRNN2D\";class g extends u.LSTMCell{constructor(t){const{filters:e,kernelSize:i,strides:r,padding:n,dataFormat:o,dilationRate:u}=t;super(Object.assign({},t,{units:e})),this.filters=e,(0,l.assertPositiveInteger)(this.filters,\"filters\"),this.kernelSize=(0,a.normalizeArray)(i,2,\"kernelSize\"),this.kernelSize.forEach(t=>(0,l.assertPositiveInteger)(t,\"kernelSize\")),this.strides=(0,a.normalizeArray)(r||1,2,\"strides\"),this.strides.forEach(t=>(0,l.assertPositiveInteger)(t,\"strides\")),this.padding=n||\"valid\",(0,s.checkPaddingMode)(this.padding),this.dataFormat=o||\"channelsLast\",(0,s.checkDataFormat)(this.dataFormat),this.dilationRate=(0,a.normalizeArray)(u||1,2,\"dilationRate\"),this.dilationRate.forEach(t=>(0,l.assertPositiveInteger)(t,\"dilationRate\"))}build(s){var i;s=(0,o.getExactlyOneShape)(s);const a=\"channelsFirst\"===this.dataFormat?1:s.length-1;if(null==s[a])throw new r.ValueError(\"The channel dimension of the input should be defined. \"+`Found ${s[a]}`);const l=s[a],u=this.kernelSize.concat([l,4*this.filters]);this.kernel=this.addWeight(\"kernel\",u,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const h=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight(\"recurrent_kernel\",h,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let s;if(this.unitForgetBias){const r=this.biasInitializer,a=this.filters;s=new((i=class extends n.Initializer{apply(s,i){const n=r.apply([a]),l=t.ones([a]),o=r.apply([2*a]);return e.concatenate([n,l,o])}}).className=\"CustomInit\",i)}else s=this.biasInitializer;this.bias=this.addWeight(\"bias\",[4*this.filters],null,s,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,s){return t.tidy(()=>{if(3!==e.length)throw new r.ValueError(\"ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got \"+`${e.length}.`);const i=s.training||!1,n=e[0],a=e[1],l=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=(0,u.generateDropoutMask)({ones:()=>t.onesLike(n),rate:this.dropout,training:i,count:4}));const o=this.dropoutMask,h=(e,s,i)=>s&&s[i]?t.mul(s[i],e):e;let c=h(n,o,0),p=h(n,o,1),d=h(n,o,2),f=h(n,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=(0,u.generateDropoutMask)({ones:()=>t.onesLike(a),rate:this.recurrentDropout,training:i,count:4}));const g=this.recurrentDropoutMask;let y=h(a,g,0),S=h(a,g,1),v=h(a,g,2),m=h(a,g,3);const[k,b,C,z]=t.split(this.kernel.read(),4,3),[w,O,M,N]=this.useBias?t.split(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,k,w,this.padding),p=this.inputConv(p,b,O,this.padding),d=this.inputConv(d,C,M,this.padding),f=this.inputConv(f,z,N,this.padding);const[D,I,_,A]=t.split(this.recurrentKernel.read(),4,3);y=this.recurrentConv(y,D),S=this.recurrentConv(S,I),v=this.recurrentConv(v,_),m=this.recurrentConv(m,A);const R=this.recurrentActivation.apply(t.add(c,y)),F=this.recurrentActivation.apply(t.add(p,S)),j=t.add(t.mul(F,l),t.mul(R,this.activation.apply(t.add(d,v)))),x=t.mul(this.recurrentActivation.apply(t.add(f,m)),this.activation.apply(j));return[x,x,j]})}getConfig(){const t=super.getConfig(),{units:e}=t,s=p(t,[\"units\"]),i={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign({},s,i)}inputConv(s,i,r,n){const a=t.conv2d(s,i,this.strides,n||\"valid\",\"channelsFirst\"===this.dataFormat?\"NCHW\":\"NHWC\",this.dilationRate);return r?e.biasAdd(a,r,this.dataFormat):a}recurrentConv(e,s){return t.conv2d(e,s,1,\"same\",\"channelsFirst\"===this.dataFormat?\"NCHW\":\"NHWC\")}}exports.ConvLSTM2DCell=g,g.className=\"ConvLSTM2DCell\",t.serialization.registerClass(g);class y extends f{constructor(t){const e=new g(t);super(Object.assign({},t,{cell:e}))}static fromConfig(t,e){return new t(e)}}exports.ConvLSTM2D=y,y.className=\"ConvLSTM2D\",t.serialization.registerClass(y);"},"sourceMaps":null,"error":null,"hash":"522342b689d8d933412e798f036a3910","cacheData":{"env":{}}}