{"id":"UZCK","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"./glsl_version","loc":{"line":17,"column":35},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js"},{"name":"./shader_compiler_util","loc":{"line":18,"column":29},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_packed_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.EncodeMatrixPackedProgram=void 0;var e=require(\"./glsl_version\"),t=r(require(\"./shader_compiler_util\"));function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function r(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=n();if(t&&t.has(e))return t.get(e);var r={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var l in e)if(Object.prototype.hasOwnProperty.call(e,l)){var s=o?Object.getOwnPropertyDescriptor(e,l):null;s&&(s.get||s.set)?Object.defineProperty(r,l,s):r[l]=e[l]}return r.default=e,t&&t.set(e,r),r}class o{constructor(n,r,o=!1){this.variableNames=[\"A\"],this.packedInputs=!1,this.packedOutput=!0;const l=(0,e.getGlslDifferences)(),[s,a]=r;this.outputShape=n;let u=\"\",c=\"result\";o&&(c=\"floor(result * 255. + 0.5)\");for(let e=0;e<=1;e++)for(let t=0;t<=1;t++){const r=2*e+t;u+=`\\n          localCoords = coords;\\n          if(localCoords[2] + ${t} < ${n[2]}) {\\n            localCoords[2] += ${t};\\n            if(localCoords[1] + ${e} < ${n[1]}) {\\n              localCoords[1] += ${e};\\n\\n              flatIndex = getFlatIndex(localCoords);\\n              offset = imod(flatIndex, 4);\\n\\n              flatIndex = idiv(flatIndex, 4, 1.);\\n\\n              r = flatIndex / ${a};\\n              c = imod(flatIndex, ${a});\\n              uv = (vec2(c, r) + halfCR) / vec2(${a}.0, ${s}.0);\\n              values = ${l.texture2D}(A, uv);\\n\\n              if(offset == 0) {\\n                result[${r}] = values[0];\\n              } else if(offset == 1) {\\n                result[${r}] = values[1];\\n              } else if(offset == 2) {\\n                result[${r}] = values[2];\\n              } else {\\n                result[${r}] = values[3];\\n              }\\n            }\\n          }\\n        `}this.userCode=`\\n      ${t.getFlatIndexFrom3D(n)}\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        vec4 result = vec4(0.);\\n        int flatIndex, r, c, offset;\\n        ivec3 localCoords;\\n        vec2 uv;\\n        vec4 values;\\n\\n        ${u}\\n\\n        ${l.output} = ${c};\\n      }\\n    `}}exports.EncodeMatrixPackedProgram=o;"},"sourceMaps":null,"error":null,"hash":"176fbafa4bcadf38c50eece23c7ec411","cacheData":{"env":{}}}