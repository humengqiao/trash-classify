{"id":"F9Be","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.CropAndResizeProgram=void 0;class e{constructor(e,t,o,n,r){this.variableNames=[\"Image\",\"Boxes\",\"BoxInd\"],this.outputShape=[];const[a,i,s,c]=e,[l]=t,[u,f]=o;this.outputShape=[l,u,f,c];const d=\"bilinear\"===n?1:0,[x,C]=[`${i-1}.0`,`${s-1}.0`],[g,R,b]=u>1?[`${(i-1)/(u-1)}`,\"(y2-y1) * height_ratio\",`y1*${x} + float(y)*(height_scale)`]:[\"0.0\",\"0.0\",`0.5 * (y1+y2) * ${x}`],[h,p,m]=f>1?[`${(s-1)/(f-1)}`,\"(x2-x1) * width_ratio\",`x1*${C} + float(x)*(width_scale)`]:[\"0.0\",\"0.0\",`0.5 * (x1+x2) * ${C}`];this.userCode=`\\n      const float height_ratio = float(${g});\\n      const float width_ratio = float(${h});\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int b = coords[0];\\n        int y = coords[1];\\n        int x = coords[2];\\n        int d = coords[3];\\n\\n        // get box vals\\n        float y1 = getBoxes(b,0);\\n        float x1 = getBoxes(b,1);\\n        float y2 = getBoxes(b,2);\\n        float x2 = getBoxes(b,3);\\n\\n        // get image in batch index\\n        int bInd = round(getBoxInd(b));\\n        if(bInd < 0 || bInd >= ${a}) {\\n          return;\\n        }\\n\\n        float height_scale = ${R};\\n        float width_scale = ${p};\\n\\n        float in_y = ${b};\\n        if( in_y < 0.0 || in_y > ${x} ) {\\n          setOutput(float(${r}));\\n          return;\\n        }\\n        float in_x = ${m};\\n        if( in_x < 0.0 || in_x > ${C} ) {\\n          setOutput(float(${r}));\\n          return;\\n        }\\n\\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\\n        if(${d} == 1) {\\n          // Compute the four integer indices.\\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\\n\\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\\n\\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\\n\\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\\n          float newValue = top + (bottom - top) * fracCR.y;\\n          setOutput(newValue);\\n        } else {\\n          // Compute the coordinators of nearest neighbor point.\\n          ivec2 sourceNearestCR = ivec2(floor(\\n            sourceFracIndexCR + vec2(0.5,0.5)));\\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\\n          setOutput(newValue);\\n        }\\n      }\\n    `}}exports.CropAndResizeProgram=e;"},"sourceMaps":null,"error":null,"hash":"d9ade9925b8470b9dacbddc556ee4f62","cacheData":{"env":{}}}