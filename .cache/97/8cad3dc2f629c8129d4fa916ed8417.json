{"id":"hTsf","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609564004117},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":18,"column":133},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"seedrandom","loc":{"line":24,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/seedrandom/index.js"},{"name":"./cpu_util","loc":{"line":25,"column":33},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/backend_cpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-cpu/dist/cpu_util.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.MathBackendCPU=void 0;var t=o(require(\"@tensorflow/tfjs-core\")),e=o(require(\"seedrandom\")),r=require(\"./cpu_util\");function s(){if(\"function\"!=typeof WeakMap)return null;var t=new WeakMap;return s=function(){return t},t}function o(t){if(t&&t.__esModule)return t;if(null===t||\"object\"!=typeof t&&\"function\"!=typeof t)return{default:t};var e=s();if(e&&e.has(t))return e.get(t);var r={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var a in t)if(Object.prototype.hasOwnProperty.call(t,a)){var n=o?Object.getOwnPropertyDescriptor(t,a):null;n&&(n.get||n.set)?Object.defineProperty(r,a,n):r[a]=t[a]}return r.default=t,e&&e.set(t,r),r}const a=t.kernel_impls.nonMaxSuppressionV3Impl,n=t.kernel_impls.split,i=t.kernel_impls.tile,l=t.kernel_impls.topkImpl,d=t.kernel_impls.whereImpl;class c extends t.KernelBackend{constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new t.DataStorage(this,(0,t.engine)())}write(e,r,s){this.firstUse&&(this.firstUse=!1,(0,t.env)().get(\"IS_NODE\")&&t.backend_util.warn(\"\\n============================\\nHi there ðŸ‘‹. Looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, which binds to TensorFlow C++, by running npm i @tensorflow/tfjs-node, or npm i @tensorflow/tfjs-node-gpu if you have CUDA. Then call require('@tensorflow/tfjs-node'); (-gpu suffix for CUDA) at the start of your program. Visit https://github.com/tensorflow/tfjs-node for more details.\\n============================\"));const o={};return this.data.set(o,{values:e,dtype:s,refCount:1}),o}makeTensorInfo(e,r,s){let o;if(\"string\"===r&&null!=s&&s.length>0&&t.util.isString(s[0])){const a=s.map(e=>t.util.encodeString(e));o=this.write(a,e,r)}else o=this.write(s,e,r);return{dataId:o,shape:e,dtype:r}}incRef(t){this.data.get(t).refCount++}decRef(t){if(this.data.has(t)){this.data.get(t).refCount--}}move(t,e,r,s){this.data.set(t,{values:e,dtype:s,refCount:1})}numDataIds(){return this.data.numDataIds()}async read(t){return this.readSync(t)}readSync(e){const{dtype:r,complexTensorInfos:s}=this.data.get(e);if(\"complex64\"===r){const e=this.readSync(s.real.dataId),r=this.readSync(s.imag.dataId);return t.backend_util.mergeRealAndImagArrays(e,r)}return this.data.get(e).values}bufferSync(e){const r=this.readSync(e.dataId);let s=r;if(\"string\"===e.dtype)try{s=r.map(e=>t.util.decodeString(e))}catch(o){throw new Error(\"Failed to decode encoded string bytes into utf-8\")}return t.buffer(e.shape,e.dtype,s)}makeOutput(e,r,s){const o=this.write(e,r,s);return(0,t.engine)().makeTensorFromDataId(o,r,s,this)}disposeData(t){if(this.data.has(t)){const{complexTensorInfos:e}=this.data.get(t);null!=e&&(this.disposeData(e.real.dataId),this.disposeData(e.imag.dataId)),this.data.delete(t)}}disposeIntermediateTensorInfo(t){const e=t.dataId;if(this.data.has(e)){const t=this.data.get(e);t.refCount--,t.refCount<1&&this.disposeData(e)}}async time(e){const r=t.util.now();return e(),{kernelMs:t.util.now()-r}}memory(){return{unreliable:!0,reasons:[\"The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less.\"]}}stridedSlice(e,s,o,a){(0,r.assertNotComplex)(e,\"stridedSlice\");const n=t.slice_util.computeOutShape(s,o,a);if(n.some(t=>0===t))return t.tensor([],n);const i=t.buffer(n,e.dtype),l=this.bufferSync(e);for(let t=0;t<i.size;t++){const e=i.indexToLoc(t),r=new Array(e.length);for(let t=0;t<r.length;t++)r[t]=e[t]*a[t]+s[t];i.set(l.get(...r),...e)}return i.toTensor()}diag(e){const r=this.readSync(e.dataId),s=t.buffer([e.size,e.size],e.dtype),o=s.values;for(let t=0;t<r.length;t++)o[t*e.size+t]=r[t];return s.toTensor()}unstack(e,r){const s=e.shape[r],o=new Array(e.rank-1);let a=0;for(let t=0;t<e.rank;t++)t!==r&&(o[a++]=e.shape[t]);const n=new Array(e.rank).fill(0),i=e.shape.slice();i[r]=1;const l=new Array(s);for(let d=0;d<l.length;d++)n[r]=d,l[d]=t.slice(e,n,i).reshape(o);return l}reverse(e,s){(0,r.assertNotComplex)(e,\"reverse\");const o=t.buffer(e.shape,e.dtype),a=this.bufferSync(e);for(let t=0;t<o.size;t++){const r=o.indexToLoc(t),n=r.slice();s.forEach(t=>n[t]=e.shape[t]-1-n[t]),o.set(a.get(...n),...r)}return o.toTensor()}neg(e){return(0,r.assertNotComplex)(e,\"neg\"),t.mul(t.scalar(-1),e)}addN(e){(0,r.assertNotComplex)(e,\"addN\");const s=e.map(t=>this.readSync(t.dataId)),o=t.buffer(e[0].shape,e[0].dtype),a=o.values;for(let t=0;t<e.length;t++){const e=s[t];for(let t=0;t<a.length;t++)a[t]+=e[t]}return o.toTensor()}softmax(e,r){const s=t.util.parseAxisParam([r],e.shape),o=(0,t.max)(e,s),a=t.backend_util.expandShapeToKeepDim(o.shape,s),n=t.sub(e,o.reshape(a)),i=t.exp(n),l=this.sum(i,s).reshape(a);return t.div(i,l)}pow(t,e){return(0,r.assertNotComplex)([t,e],\"pow\"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.pow(t,e))}floorDiv(t,e){(0,r.assertNotComplex)([t,e],\"floorDiv\");return this.broadcastedBinaryOp(t,e,\"int32\",(t,e)=>Math.floor(t/e))}sum(e,s){(0,r.assertNotComplex)(e,\"sum\"),t.backend_util.assertAxesAreInnerMostDims(\"sum\",s,e.rank);const[o,a]=t.backend_util.computeOutAndReduceShapes(e.shape,s),n=(0,t.upcastType)(e.dtype,\"int32\"),i=t.zeros(o,n),l=t.util.sizeFromShape(a),d=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let t=0;t<d.length;++t){const e=t*l;let r=0;for(let t=0;t<l;++t)r+=c[e+t];d[t]=r}return i}prod(e,s){(0,r.assertNotComplex)(e,\"sum\");const[o,a]=t.backend_util.computeOutAndReduceShapes(e.shape,s),n=(0,t.upcastType)(e.dtype,\"int32\"),i=t.zeros(o,n),l=t.util.sizeFromShape(a),d=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let t=0;t<d.length;++t){const e=t*l;let r=1;for(let t=0;t<l;++t)r*=c[e+t];d[t]=r}return i}unsortedSegmentSum(e,s,o){(0,r.assertNotComplex)(e,\"unsortedSegmentSum\");const a=[],n=e.rank-s.rank;for(let t=0;t<n;++t)s=s.expandDims(t+1);for(let r=0;r<o;++r){const o=t.scalar(r,\"int32\"),n=t.equal(o,s).asType(\"float32\").mul(e).sum(0);a.push(n)}return t.stack(a)}argMin(e,s){(0,r.assertNotComplex)(e,\"argMin\");const o=[s];t.backend_util.assertAxesAreInnerMostDims(\"argMin\",o,e.rank);const[a,n]=t.backend_util.computeOutAndReduceShapes(e.shape,o),i=t.zeros(a,\"int32\"),l=t.util.sizeFromShape(n),d=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let t=0;t<d.length;++t){const e=t*l;let r=c[e],s=0;for(let t=0;t<l;++t){const o=c[e+t];o<r&&(r=o,s=t)}d[t]=s}return i}argMax(e,s){(0,r.assertNotComplex)(e,\"argMax\");const o=[s];t.backend_util.assertAxesAreInnerMostDims(\"argMax\",o,e.rank);const[a,n]=t.backend_util.computeOutAndReduceShapes(e.shape,o),i=t.zeros(a,\"int32\"),l=t.util.sizeFromShape(n),d=this.readSync(i.dataId),c=this.readSync(e.dataId);for(let t=0;t<d.length;++t){const e=t*l;let r=c[e],s=0;for(let t=0;t<l;++t){const o=c[e+t];o>r&&(r=o,s=t)}d[t]=s}return i}cumsum(e,s,o,a){if((0,r.assertNotComplex)(e,\"cumsum\"),s!==e.rank-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${e.rank-1} `+`but got axis=${s}`);const n=(0,t.upcastType)(e.dtype,\"int32\"),i=t.zeros(e.shape,n),l=this.readSync(i.dataId),d=this.readSync(e.dataId),c=e.shape[e.rank-1],h=a?(t,e)=>t+c-e-1:(t,e)=>t+e;for(let t=0;t<d.length;t+=c)for(let e=0;e<c;e++){const r=h(t,e);if(0===e)l[r]=o?0:d[r];else{const s=h(t,e-1);l[r]=o?d[s]+l[s]:d[r]+l[s]}}return i}equal(t,e){return(0,r.assertNotComplex)([t,e],\"equal\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t===e?1:0)}notEqual(t,e){return(0,r.assertNotComplex)([t,e],\"notEqual\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t!==e?1:0)}less(t,e){return(0,r.assertNotComplex)([t,e],\"less\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t<e?1:0)}lessEqual(t,e){return(0,r.assertNotComplex)([t,e],\"lessEqual\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t<=e?1:0)}greater(t,e){return(0,r.assertNotComplex)([t,e],\"greater\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t>e?1:0)}greaterEqual(t,e){return(0,r.assertNotComplex)([t,e],\"greaterEqual\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t>=e?1:0)}logicalAnd(t,e){return(0,r.assertNotComplex)([t,e],\"logicalAnd\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t&&e)}logicalOr(t,e){return(0,r.assertNotComplex)([t,e],\"logicalOr\"),this.broadcastedBinaryOp(t,e,\"bool\",(t,e)=>t||e)}select(e,s,o){(0,r.assertNotComplex)([e,s,o],\"select\");const a=this.readSync(e.dataId),n=this.readSync(s.dataId),i=this.readSync(o.dataId),l=t.zeros(s.shape,(0,t.upcastType)(s.dtype,o.dtype)),d=this.readSync(l.dataId);let c=0;const h=0===e.rank||e.rank>1||1===s.rank?1:t.util.sizeFromShape(s.shape.slice(1));for(let t=0;t<a.length;t++)for(let e=0;e<h;e++)1===a[t]?d[c++]=n[t]:d[c++]=i[t];return l}where(t){(0,r.assertNotComplex)([t],\"where\");const e=this.readSync(t.dataId);return d(t.shape,e)}topk(t,e,s){(0,r.assertNotComplex)(t,\"topk\");const o=this.readSync(t.dataId);return l(o,t.shape,t.dtype,e,s)}min(e,s){(0,r.assertNotComplex)(e,\"min\"),t.backend_util.assertAxesAreInnerMostDims(\"min\",s,e.rank);const[o,a]=t.backend_util.computeOutAndReduceShapes(e.shape,s),n=t.zeros(o,e.dtype),i=t.util.sizeFromShape(a),l=this.readSync(n.dataId),d=this.readSync(e.dataId);for(let t=0;t<l.length;++t){const e=t*i;let r=d[e];for(let t=0;t<i;++t){const s=d[e+t];s<r&&(r=s)}l[t]=r}return n}minimum(t,e){return(0,r.assertNotComplex)([t,e],\"minimum\"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.min(t,e))}mod(t,e){return(0,r.assertNotComplex)([t,e],\"mod\"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const r=t%e;return t<0&&e<0||t>=0&&e>=0?r:(r+e)%e})}maximum(t,e){return(0,r.assertNotComplex)([t,e],\"maximum\"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.max(t,e))}all(e,s){(0,r.assertNotComplex)(e,\"all\"),t.backend_util.assertAxesAreInnerMostDims(\"all\",s,e.rank);const[o,a]=t.backend_util.computeOutAndReduceShapes(e.shape,s),n=t.zeros(o,e.dtype),i=t.util.sizeFromShape(a),l=this.readSync(n.dataId),d=this.readSync(e.dataId);for(let t=0;t<l.length;++t){const e=t*i;let r=d[e];for(let t=0;t<i;++t){const s=d[e+t];r=r&&s}l[t]=r}return n}any(e,s){(0,r.assertNotComplex)(e,\"any\"),t.backend_util.assertAxesAreInnerMostDims(\"any\",s,e.rank);const[o,a]=t.backend_util.computeOutAndReduceShapes(e.shape,s),n=t.zeros(o,e.dtype),i=t.util.sizeFromShape(a),l=this.readSync(n.dataId),d=this.readSync(e.dataId);for(let t=0;t<l.length;++t){const e=t*i;let r=d[e];for(let t=0;t<i;++t){const s=d[e+t];r=r||s}l[t]=r}return n}squaredDifference(t,e){return(0,r.assertNotComplex)([t,e],\"squaredDifference\"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>{const r=t-e;return r*r})}eluDer(t,e){(0,r.assertNotComplex)([t,e],\"eluDer\");const s=new Float32Array(e.size),o=this.readSync(e.dataId),a=this.readSync(t.dataId);for(let r=0;r<o.length;++r){const t=o[r];s[r]=t>=1?a[r]:a[r]*(t+1)}return this.makeOutput(s,e.shape,\"float32\")}atan2(t,e){return(0,r.assertNotComplex)([t,e],\"atan2\"),this.broadcastedBinaryOp(t,e,t.dtype,(t,e)=>Math.atan2(t,e))}tile(t,e){return(0,r.assertNotComplex)(t,\"tile\"),i(this.bufferSync(t),e)}gather(e,s,o){(0,r.assertNotComplex)([e,s],\"gather\");const a=e.shape.slice(),n=this.readSync(s.dataId);a[o]=n.length;const i=t.buffer(a,e.dtype),l=this.bufferSync(e);for(let t=0;t<i.size;++t){const e=i.indexToLoc(t),r=e.slice();r[o]=n[e[o]];const s=l.locToIndex(r);i.values[t]=l.values[s]}return i.toTensor()}batchToSpaceND(e,s,o){(0,r.assertNotComplex)([e],\"batchToSpaceND\");const a=s.reduce((t,e)=>t*e),n=t.backend_util.getReshaped(e.shape,s,a),i=t.backend_util.getPermuted(n.length,s.length),l=t.backend_util.getReshapedPermuted(e.shape,s,a),d=t.backend_util.getSliceBeginCoords(o,s.length),c=t.backend_util.getSliceSize(l,o,s.length);return t.transpose(e.reshape(n),i).reshape(l).slice(d,c)}pool3d(e,s,o){(0,r.assertNotComplex)(e,\"pool3d\");const a=s.strideDepth,n=s.strideHeight,i=s.strideWidth,l=s.dilationDepth,d=s.dilationHeight,c=s.dilationWidth,h=s.effectiveFilterDepth,p=s.effectiveFilterHeight,u=s.effectiveFilterWidth,f=s.padInfo.front,m=s.padInfo.top,y=s.padInfo.left,g=\"max\"===o?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,S=this.readSync(e.dataId),b=t.buffer(s.outShape,e.dtype),I=b.values,x=s.outShape[1]*s.outShape[2]*s.outShape[3]*s.outShape[4],k=s.outShape[2]*s.outShape[3]*s.outShape[4],N=s.outShape[3]*s.outShape[4],M=s.outShape[4];for(let t=0;t<s.batchSize;++t){const r=t*x,b=t*e.strides[0];for(let t=0;t<s.inChannels;++t)for(let x=0;x<s.outDepth;++x){const C=x*a-f;let D=C;for(;D<0;)D+=l;const z=Math.min(s.inDepth,h+C),w=r+x*k;for(let r=0;r<s.outHeight;++r){const a=r*n-m;let h=a;for(;h<0;)h+=d;const f=Math.min(s.inHeight,p+a),x=w+r*N;for(let r=0;r<s.outWidth;++r){const a=r*i-y;let n=a;for(;n<0;)n+=c;const p=Math.min(s.inWidth,u+a),m=x+r*M;let k=g,N=0,C=0;for(let r=D;r<z;r+=l){const s=b+r*e.strides[1];for(let r=h;r<f;r+=d){const a=s+r*e.strides[2];for(let r=n;r<p;r+=c){const s=S[a+r*e.strides[3]+t];if(\"max\"===o&&s>k?k=s:\"avg\"===o&&(N+=s,C++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}I[m+t]=\"avg\"===o?N/C:k}}}}return b.toTensor()}avgPool3d(t,e){return(0,r.assertNotComplex)(t,\"avgPool3d\"),this.pool3d(t,e,\"avg\").toFloat()}avgPool3dBackprop(e,s,o){(0,r.assertNotComplex)([e,s],\"avgPool3dBackprop\");const a=o.strideDepth,n=o.strideHeight,i=o.strideWidth,l=o.filterDepth,d=o.filterHeight,c=o.filterWidth,h=o.dilationDepth,p=o.dilationHeight,u=o.dilationWidth,f=o.effectiveFilterDepth,m=o.effectiveFilterHeight,y=o.effectiveFilterWidth,g=f-1-o.padInfo.front,S=y-1-o.padInfo.left,b=m-1-o.padInfo.top,I=t.buffer(s.shape,\"float32\"),x=1/(l*d*c),k=this.bufferSync(e);for(let t=0;t<o.batchSize;++t)for(let e=0;e<o.inChannels;++e)for(let r=0;r<o.inDepth;++r)for(let s=0;s<o.inHeight;++s)for(let l=0;l<o.inWidth;++l){const d=r-g,c=s-b,N=l-S;let M=0;for(let r=0;r<f;r+=h){const s=(d+r)/a;if(!(s<0||s>=o.outDepth||Math.floor(s)!==s))for(let r=0;r<m;r+=p){const a=(c+r)/n;if(!(a<0||a>=o.outHeight||Math.floor(a)!==a))for(let r=0;r<y;r+=u){const n=(N+r)/i;n<0||n>=o.outWidth||Math.floor(n)!==n||(M+=k.get(t,s,a,n,e))}}}I.set(M*x,t,r,s,l,e)}return I.toTensor()}maxPool3d(t,e){return(0,r.assertNotComplex)(t,\"maxPool3d\"),this.pool3d(t,e,\"max\").toFloat()}maxPool3dPositions(e,r){const s=t.buffer(r.outShape,\"int32\"),o=r.strideDepth,a=r.strideHeight,n=r.strideWidth,i=r.dilationDepth,l=r.dilationHeight,d=r.dilationWidth,c=r.effectiveFilterDepth,h=r.effectiveFilterHeight,p=r.effectiveFilterWidth,u=r.padInfo.front,f=r.padInfo.top,m=r.padInfo.left,y=this.bufferSync(e);for(let t=0;t<r.batchSize;++t)for(let e=0;e<r.inChannels;++e)for(let g=0;g<r.outDepth;++g){const S=g*o-u;let b=S;for(;b<0;)b+=i;const I=Math.min(r.inDepth,c+S);for(let o=0;o<r.outHeight;++o){const c=o*a-f;let u=c;for(;u<0;)u+=l;const x=Math.min(r.inHeight,h+c);for(let a=0;a<r.outWidth;++a){const f=a*n-m;let k=f;for(;k<0;)k+=d;const N=Math.min(r.inWidth,p+f);let M=Number.NEGATIVE_INFINITY,C=-1;for(let r=b;r<I;r+=i){const s=r-S;for(let o=u;o<x;o+=l){const a=o-c;for(let n=k;n<N;n+=d){const i=n-f,l=y.get(t,r,o,n,e);l>=M&&(M=l,C=s*h*p+a*h+i)}}}s.set(C,t,g,o,a,e)}}}return s.toTensor()}maxPool3dBackprop(e,s,o,a){(0,r.assertNotComplex)([s,o],\"maxPool3dBackprop\");const n=this.maxPool3dPositions(s,a),i=a.strideDepth,l=a.strideHeight,d=a.strideWidth,c=a.dilationDepth,h=a.dilationHeight,p=a.dilationWidth,u=a.effectiveFilterDepth,f=a.effectiveFilterHeight,m=a.effectiveFilterWidth,y=u-1-a.padInfo.front,g=m-1-a.padInfo.left,S=f-1-a.padInfo.top,b=t.buffer(s.shape,\"float32\"),I=this.bufferSync(n),x=this.bufferSync(e);for(let t=0;t<a.batchSize;++t)for(let e=0;e<a.inChannels;++e)for(let r=0;r<a.inDepth;++r)for(let s=0;s<a.inHeight;++s)for(let o=0;o<a.inWidth;++o){const n=r-y,k=s-S,N=o-g;let M=0;for(let r=0;r<u;r+=c){const s=(n+r)/i;if(!(s<0||s>=a.outDepth||Math.floor(s)!==s))for(let o=0;o<f;o+=h){const n=(k+o)/l;if(!(n<0||n>=a.outHeight||Math.floor(n)!==n))for(let i=0;i<m;i+=p){const l=(N+i)/d;if(l<0||l>=a.outWidth||Math.floor(l)!==l)continue;const c=u*f*m-1-I.get(t,s,n,l,e)===r*f*m+o*m+i?1:0;0!==c&&(M+=x.get(t,s,n,l,e)*c)}}}b.set(M,t,r,s,o,e)}return b.toTensor()}resizeBilinear(e,s,o,a){(0,r.assertNotComplex)(e,\"resizeBilinear\");const[n,i,l,d]=e.shape,c=this.readSync(e.dataId),h=new Float32Array(t.util.sizeFromShape([n,s,o,d])),p=[a&&s>1?i-1:i,a&&o>1?l-1:l],u=[a&&s>1?s-1:s,a&&o>1?o-1:o];let f=0;const m=p[0]/u[0],y=p[1]/u[1];for(let t=0;t<n;t++)for(let r=0;r<s;r++){const s=m*r,a=Math.floor(s),n=s-a,p=Math.min(i-1,Math.ceil(s)),u=t*e.strides[0]+a*e.strides[1],g=t*e.strides[0]+p*e.strides[1];for(let t=0;t<o;t++){const r=y*t,s=Math.floor(r),o=r-s,a=Math.min(l-1,Math.ceil(r)),i=u+s*e.strides[2],p=g+s*e.strides[2],m=u+a*e.strides[2],S=g+a*e.strides[2];for(let t=0;t<d;t++){const e=c[i+t],r=c[p+t],s=e+(c[m+t]-e)*o,a=s+(r+(c[S+t]-r)*o-s)*n;h[f++]=a}}}return t.tensor(h,[n,s,o,d])}resizeBilinearBackprop(e,s,o){(0,r.assertNotComplex)([e,s],\"resizeBilinearBackprop\");const[a,n,i,l]=s.shape,[,d,c]=e.shape,h=new Float32Array(a*n*i*l),p=[o&&d>1?n-1:n,o&&c>1?i-1:i],u=[o&&d>1?d-1:d,o&&c>1?c-1:c],f=p[0]/u[0],m=p[1]/u[1],y=this.readSync(e.dataId);let g=0;for(let t=0;t<a;t++){const e=t*s.strides[0];for(let t=0;t<d;t++){const r=t*f,o=Math.floor(r),a=Math.min(Math.ceil(r),n-1),d=e+o*s.strides[1],p=e+a*s.strides[1],u=r-o,S=1-u;for(let t=0;t<c;t++){const e=t*m,r=Math.floor(e),o=Math.min(Math.ceil(e),i-1),a=e-r,n=1-a,c=d+r*s.strides[2],f=d+o*s.strides[2],b=p+r*s.strides[2],I=p+o*s.strides[2],x=S*n,k=S*a,N=u*n,M=u*a;for(let t=0;t<l;t++){const e=y[g++];h[c+t]+=e*x,h[f+t]+=e*k,h[b+t]+=e*N,h[I+t]+=e*M}}}}return t.tensor4d(h,[a,i,n,l],s.dtype)}resizeNearestNeighbor(e,s,o,a){(0,r.assertNotComplex)(e,\"resizeNearestNeighbor\");const[n,i,l,d]=e.shape,c=this.readSync(e.dataId),h=new Float32Array(n*s*o*d),p=[a&&s>1?i-1:i,a&&o>1?l-1:l],u=[a&&s>1?s-1:s,a&&o>1?o-1:o],f=p[0]/u[0],m=p[1]/u[1];let y=0;for(let t=0;t<n;t++){const r=t*e.strides[0];for(let t=0;t<s;t++){const s=f*t,n=r+Math.min(i-1,a?Math.round(s):Math.floor(s))*e.strides[1];for(let t=0;t<o;t++){const r=m*t,s=n+Math.min(l-1,a?Math.round(r):Math.floor(r))*e.strides[2];for(let t=0;t<d;t++){const e=c[s+t];h[y++]=e}}}}return t.tensor(h,[n,s,o,d],e.dtype)}resizeNearestNeighborBackprop(e,s,o){(0,r.assertNotComplex)([e,s],\"resizeNearestNeighborBackprop\");const[a,n,i,l]=s.shape,[,d,c]=e.shape,h=new Float32Array(a*n*i*l),p=this.readSync(e.dataId),u=[o&&d>1?n-1:n,o&&c>1?i-1:i],f=[o&&d>1?d-1:d,o&&c>1?c-1:c],m=u[0]/f[0],y=u[1]/f[1],g=1/m,S=1/y,b=2*Math.ceil(g)+2,I=2*Math.ceil(S)+2;for(let t=0;t<a;t++){const r=t*s.strides[0];for(let t=0;t<n;t++){const a=r+t*s.strides[1],u=Math.floor(t*g),f=Math.floor(u-b/2);for(let g=0;g<i;g++){const u=a+g*s.strides[2],x=Math.floor(g*S),k=Math.floor(x-I/2);for(let s=0;s<l;s++){let a=0;for(let l=0;l<b;l++){const h=l+f;if(h<0||h>=d)continue;const u=r+h*e.strides[1],S=h*m;if(t===Math.min(n-1,o?Math.round(S):Math.floor(S)))for(let t=0;t<I;t++){const r=t+k;if(r<0||r>=c)continue;const n=u+r*e.strides[2],l=r*y;g===Math.min(i-1,o?Math.round(l):Math.floor(l))&&(a+=p[n+s])}}h[u+s]=a}}}}return t.tensor4d(h,s.shape,s.dtype)}localResponseNormalization4D(e,s,o,a,n){(0,r.assertNotComplex)(e,\"localResponseNormalization4D\");const i=e.shape[3],l=i-1,d=this.readSync(e.dataId),c=e.size,h=new Float32Array(c);function p(t){const e=t%i;let r=t-e+Math.max(0,e-s);const o=t-e+Math.min(e+s,l);let a=0;for(;r<=o;r++){const t=d[r];a+=t*t}return a}for(let t=0;t<c;t++){const e=p(t),r=d[t]*Math.pow(o+a*e,-n);h[t]=r}return t.tensor4d(h,e.shape)}LRNGrad(e,s,o,a,n,i,l){(0,r.assertNotComplex)(e,\"LRNGrad\");const d=e.shape[3],c=this.readSync(e.dataId),h=this.readSync(s.dataId),p=this.readSync(o.dataId),u=new Float32Array(e.size),f=e.size;for(let t=0;t<f;t++){const e=t%d,r=t-e+Math.max(0,e-a),s=t-e+Math.min(d,e+a+1);let o=0;for(let t=r;t<s;t++)o+=Math.pow(h[t],2);o=i*o+n;for(let a=r;a<s;a++){let e=-2*i*l*h[a]*p[t]/o;t===a&&(e+=Math.pow(o,-l)),e*=c[t],u[a]+=e}}return t.tensor4d(u,e.shape)}multinomial(s,o,a,n){(0,r.assertNotComplex)(s,\"multinomial\");const i=o?s:t.softmax(s),l=i.shape[0],d=i.shape[1],c=t.zeros([l,a],\"int32\"),h=this.readSync(c.dataId),p=this.readSync(i.dataId);for(let t=0;t<l;++t){const r=t*d,s=new Float32Array(d-1);s[0]=p[r];for(let t=1;t<s.length;++t)s[t]=s[t-1]+p[r+t];const o=e.alea(n.toString()),i=t*a;for(let t=0;t<a;++t){const e=o();h[i+t]=s.length;for(let r=0;r<s.length;r++)if(e<s[r]){h[i+t]=r;break}}}return c}oneHot(e,s,o,a){(0,r.assertNotComplex)(e,\"oneHot\");const n=new Float32Array(e.size*s);n.fill(a);const i=this.readSync(e.dataId);for(let t=0;t<e.size;++t)i[t]>=0&&i[t]<s&&(n[t*s+i[t]]=o);return t.tensor2d(n,[e.size,s],\"int32\")}nonMaxSuppression(t,e,s,o,n){(0,r.assertNotComplex)(t,\"nonMaxSuppression\");const i=this.readSync(t.dataId),l=this.readSync(e.dataId);return a(i,l,s,o,n)}depthToSpace(e,r,s){t.util.assert(\"NHWC\"===s,()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${s}`),t.util.assert(r>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${r}`);const o=e.shape[0],a=e.shape[1],n=e.shape[2],i=e.shape[3],l=a*r,d=n*r,c=i/(r*r),h=this.readSync(e.dataId),p=new Float32Array(o*l*d*c);let u=0;for(let t=0;t<o;++t)for(let e=0;e<l;++e){const s=Math.floor(e/r),o=e%r;for(let e=0;e<d;++e){const l=Math.floor(e/r),d=(o*r+e%r)*c;for(let e=0;e<c;++e){const r=e+d+i*(l+n*(s+a*t));p[u++]=h[r]}}}return t.tensor4d(p,[o,l,d,c])}broadcastedBinaryOp(e,r,s,o){const a=t.backend_util.assertAndGetBroadcastShape(e.shape,r.shape),n=t.buffer(a,s),i=this.readSync(e.dataId),l=this.readSync(r.dataId),d=t.backend_util.getBroadcastDims(e.shape,a),c=t.backend_util.getBroadcastDims(r.shape,a),h=n.values;if(d.length+c.length===0)for(let t=0;t<h.length;++t)h[t]=o(i[t%i.length],l[t%l.length]);else{const t=this.bufferSync(e),s=this.bufferSync(r);for(let a=0;a<h.length;++a){const p=n.indexToLoc(a),u=p.slice(-e.rank);d.forEach(t=>u[t]=0);const f=t.locToIndex(u),m=p.slice(-r.rank);c.forEach(t=>m[t]=0);const y=s.locToIndex(m);h[a]=o(i[f],l[y])}}return n.toTensor()}split(t,e,r){return n(t,e,r)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}cropAndResize(e,r,s,o,a,n){const[i,l,d,c]=e.shape,h=r.shape[0],[p,u]=o,f=t.buffer([h,p,u,c],\"float32\"),m=this.readSync(r.dataId),y=this.readSync(s.dataId),g=this.readSync(e.dataId),S=e.strides,b=f.strides;for(let t=0;t<h;t++){const e=4*t,r=m[e],s=m[e+1],o=m[e+2],h=m[e+3],I=y[t];if(I>=i)continue;const x=p>1?(o-r)*(l-1)/(p-1):0,k=u>1?(h-s)*(d-1)/(u-1):0;for(let i=0;i<p;i++){const e=p>1?r*(l-1)+i*x:.5*(r+o)*(l-1);if(e<0||e>l-1)for(let r=0;r<u;r++)for(let e=0;e<c;e++){const s=e+r*b[2]+i*b[1]+t*b[0];f.values[s]=n}else if(\"bilinear\"===a){const r=Math.floor(e),o=Math.ceil(e),a=e-r;for(let e=0;e<u;e++){const l=u>1?s*(d-1)+e*k:.5*(s+h)*(d-1);if(l<0||l>d-1){for(let r=0;r<c;r++){const s=r+e*b[2]+i*b[1]+t*b[0];f.values[s]=n}continue}const p=Math.floor(l),m=Math.ceil(l),y=l-p;for(let s=0;s<c;s++){let n=s+p*S[2]+r*S[1]+I*S[0];const l=g[n],d=g[n=s+m*S[2]+r*S[1]+I*S[0]],c=g[n=s+p*S[2]+o*S[1]+I*S[0]],h=l+(d-l)*y,u=c+(g[n=s+m*S[2]+o*S[1]+I*S[0]]-c)*y;n=s+e*b[2]+i*b[1]+t*b[0],f.values[n]=h+(u-h)*a}}}else for(let r=0;r<u;++r){const o=u>1?s*(d-1)+r*k:.5*(s+h)*(d-1);if(o<0||o>d-1){for(let e=0;e<c;e++){const s=e+r*b[2]+i*b[1]+t*b[0];f.values[s]=n}continue}const a=Math.round(o),l=Math.round(e);for(let e=0;e<c;e++){const s=e+a*S[2]+l*S[1]+I*S[0],o=e+r*b[2]+i*b[1]+t*b[0];f.values[o]=g[s]}}}}return f.toTensor()}sparseToDense(e,r,s,o){const{sliceRank:a,numUpdates:n,sliceSize:i,strides:l,outputSize:d}=t.backend_util.calculateShapes(r,e,s);return this.scatter(e,r,s,d,i,n,a,l,o,!1)}gatherND(e,r){const s=r.shape,o=s[s.length-1],[a,n,i,l]=t.backend_util.prepareAndValidate(e,r);if(0===n)return t.tensor([],a,e.dtype);const d=new t.TensorBuffer([n,i],e.dtype),c=this.readSync(r.dataId),h=this.readSync(e.dataId);for(let t=0;t<n;t++){const r=[];let s=0;for(let e=0;e<o;e++){const a=c[t*o+e];s+=a*l[e],r.push(a)}if(s<0||s>=e.size/i)throw new Error(`Invalid indices: ${r} does not index into ${e.shape}`);for(let e=0;e<i;e++)d.values[t*i+e]=h[s*i+e]}return d.toTensor().reshape(a)}scatterND(e,r,s){const{sliceRank:o,numUpdates:a,sliceSize:n,strides:i,outputSize:l}=t.backend_util.calculateShapes(r,e,s),d=t.scalar(0);return this.scatter(e,r,s,l,n,a,o,i,d,!0)}onesLike(e){if(\"string\"===e.dtype)throw new Error(\"onesLike is not supported for string tensors\");return t.fill(e.shape,1,e.dtype)}zerosLike(e){const r=t.util.getArrayFromDType(e.dtype,t.util.sizeFromShape(e.shape));return this.makeOutput(r,e.shape,e.dtype)}linspace(e,r,s){return t.backend_util.linspaceImpl(e,r,s)}scatter(e,r,s,o,a,n,i,l,d,c){const h=[o/a,a],p=this.readSync(e.dataId),u=this.readSync(r.dataId);if(0===o)return t.tensor([],s,r.dtype);const f=new t.TensorBuffer(h,r.dtype);f.values.fill(this.readSync(d.dataId)[0]);for(let t=0;t<n;t++){const e=[];let n=0;for(let r=0;r<i;r++){const s=p[t*i+r];e.push(s),n+=s*l[r]}if(n<0||n>=o/a)throw new Error(`Invalid indices: ${e} does not index into ${s}`);for(let s=0;s<a;s++)c?f.values[n*a+s]+=u[t*a+s]:f.values[n*a+s]=0===r.rank?u[0]:u[t*a+s]}return f.toTensor().reshape(s)}}exports.MathBackendCPU=c;"},"sourceMaps":null,"error":null,"hash":"700c902cd0f92f7a2447a95164f04ba0","cacheData":{"env":{}}}