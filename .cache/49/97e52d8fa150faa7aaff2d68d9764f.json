{"id":"VR5t","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":499162500000},{"name":"./engine","loc":{"line":17,"column":23},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/gradients.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/engine.js"},{"name":"./tensor","loc":{"line":18,"column":33},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/gradients.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/tensor.js"},{"name":"./tensor_util_env","loc":{"line":19,"column":54},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/gradients.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/tensor_util_env.js"},{"name":"./util","loc":{"line":20,"column":22},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/gradients.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/util.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.customGrad=f,exports.variableGrads=d,exports.valueAndGrad=i,exports.valueAndGrads=l,exports.grad=o,exports.grads=u;var e=require(\"./engine\"),r=require(\"./tensor\"),a=require(\"./tensor_util_env\"),s=n(require(\"./util\"));function t(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return t=function(){return e},e}function n(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var r=t();if(r&&r.has(e))return r.get(e);var a={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var o=s?Object.getOwnPropertyDescriptor(e,n):null;o&&(o.get||o.set)?Object.defineProperty(a,n,o):a[n]=e[n]}return a.default=e,r&&r.set(e,a),a}function o(r){return s.assert(s.isFunction(r),()=>\"The f passed in grad(f) must be a function\"),(t,n)=>{const o=(0,a.convertToTensor)(t,\"x\",\"tf.grad\",null),u=null!=n?(0,a.convertToTensor)(n,\"dy\",\"tf.grad\"):null;return e.ENGINE.tidy(()=>{const{value:a,grads:t}=e.ENGINE.gradients(()=>r(o),[o],u);return null!=u&&s.assertShapesMatch(a.shape,u.shape,\"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)\"),c(t),t[0]})}}function u(r){return s.assert(s.isFunction(r),()=>\"The f passed in grads(f) must be a function\"),(t,n)=>{s.assert(Array.isArray(t),()=>\"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s\");const o=(0,a.convertToTensorArray)(t,\"args\",\"tf.grads\",null),u=null!=n?(0,a.convertToTensor)(n,\"dy\",\"tf.grads\"):null;return e.ENGINE.tidy(()=>{const{value:a,grads:t}=e.ENGINE.gradients(()=>r(...o),o,u);return null!=u&&s.assertShapesMatch(a.shape,u.shape,\"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),c(t),t})}}function i(a){return s.assert(s.isFunction(a),()=>\"The f passed in valueAndGrad(f) must be a function\"),(t,n)=>{s.assert(t instanceof r.Tensor,()=>\"The x passed in valueAndGrad(f)(x) must be a tensor\"),s.assert(null==n||n instanceof r.Tensor,()=>\"The dy passed in valueAndGrad(f)(x, dy) must be a tensor\");const{grads:o,value:u}=e.ENGINE.gradients(()=>a(t),[t],n);return c(o),{grad:o[0],value:u}}}function l(a){return s.assert(s.isFunction(a),()=>\"The f passed in valueAndGrads(f) must be a function\"),(t,n)=>{s.assert(Array.isArray(t)&&t.every(e=>e instanceof r.Tensor),()=>\"The args passed in valueAndGrads(f)(args) must be array of tensors\"),s.assert(null==n||n instanceof r.Tensor,()=>\"The dy passed in valueAndGrads(f)(args, dy) must be a tensor\");const o=e.ENGINE.gradients(()=>a(...t),t,n);return null!=n&&s.assertShapesMatch(o.value.shape,n.shape,\"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])\"),c(o.grads),o}}function d(a,t){s.assert(s.isFunction(a),()=>\"The f passed in variableGrads(f) must be a function\"),s.assert(null==t||Array.isArray(t)&&t.every(e=>e instanceof r.Variable),()=>\"The varList passed in variableGrads(f, varList) must be an array of variables\");const n=null!=t;if(!n){t=[];for(const r in e.ENGINE.registeredVariables)t.push(e.ENGINE.registeredVariables[r])}const o=n?t.filter(e=>!e.trainable):null,u=t.length;t=t.filter(e=>e.trainable),s.assert(t.length>0,()=>\"variableGrads() expects at least one of the input variables to \"+`be trainable, but none of the ${u} variables is `+\"trainable.\");const{value:i,grads:l}=e.ENGINE.gradients(a,t,null,!0);s.assert(l.some(e=>null!=e),()=>\"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().\"),s.assert(0===i.rank,()=>\"The f passed in variableGrads(f) must return a scalar, but it \"+`returned a rank-${i.rank} tensor`);const d={};return t.forEach((e,r)=>{null!=l[r]&&(d[e.name]=l[r])}),null!=o&&o.forEach(e=>d[e.name]=null),{value:i,grads:d}}function f(r){return e.ENGINE.customGrad(r)}function c(e){if(e.filter(e=>null==e).length>0)throw new Error(\"Cannot compute gradient of y=f(x) with respect to x. Make sure that\\n    the f you passed encloses all operations that lead from x to y.\")}"},"sourceMaps":null,"error":null,"hash":"d8f1970584094f85cc5435fb7a266c57","cacheData":{"env":{}}}