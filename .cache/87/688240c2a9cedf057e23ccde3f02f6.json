{"id":"inkj","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609564004117},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":27},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"@tensorflow/tfjs-core/dist/ops/ops_for_converter","loc":{"line":19,"column":23},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/ops/ops_for_converter.js"},{"name":"./utils","loc":{"line":20,"column":30},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/slice_join_executor.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-converter/dist/operations/executors/utils.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.CATEGORY=exports.executeOp=void 0;var e=require(\"@tensorflow/tfjs-core\"),a=s(require(\"@tensorflow/tfjs-core/dist/ops/ops_for_converter\")),t=require(\"./utils\");function r(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return r=function(){return e},e}function s(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var a=r();if(a&&a.has(e))return a.get(e);var t={},s=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(Object.prototype.hasOwnProperty.call(e,u)){var n=s?Object.getOwnPropertyDescriptor(e,u):null;n&&(n.get||n.set)?Object.defineProperty(t,u,n):t[u]=e[u]}return t.default=e,a&&a.set(e,t),t}const u=(r,s,u)=>{switch(r.op){case\"ConcatV2\":case\"Concat\":{const e=(0,t.getParamValue)(\"n\",r,s,u),n=(0,t.getParamValue)(\"axis\",r,s,u);let l=(0,t.getParamValue)(\"tensors\",r,s,u);return l=l.slice(0,e),[a.concat(l,n)]}case\"GatherV2\":case\"Gather\":{const e=(0,t.getParamValue)(\"axis\",r,s,u),n=(0,t.getParamValue)(\"x\",r,s,u),l=(0,t.getParamValue)(\"indices\",r,s,u);return[a.gather(n,a.cast(l,\"int32\"),e)]}case\"ReverseV2\":case\"Reverse\":{const e=(0,t.getParamValue)(\"axis\",r,s,u),n=(0,t.getParamValue)(\"x\",r,s,u);return[a.reverse(n,e)]}case\"Slice\":{const e=(0,t.getParamValue)(\"begin\",r,s,u),n=(0,t.getParamValue)(\"size\",r,s,u);return[a.slice((0,t.getParamValue)(\"x\",r,s,u),e,n)]}case\"StridedSlice\":{const e=(0,t.getParamValue)(\"begin\",r,s,u),n=(0,t.getParamValue)(\"end\",r,s,u),l=(0,t.getParamValue)(\"strides\",r,s,u),c=(0,t.getParamValue)(\"beginMask\",r,s,u),o=(0,t.getParamValue)(\"endMask\",r,s,u),i=(0,t.getParamValue)(\"ellipsisMask\",r,s,u),p=(0,t.getParamValue)(\"newAxisMask\",r,s,u),g=(0,t.getParamValue)(\"shrinkAxisMask\",r,s,u),P=(0,t.getParamValue)(\"x\",r,s,u);return[a.stridedSlice(P,e,n,l,c,o,i,p,g)]}case\"Pack\":return(0,e.tidy)(()=>{const n=(0,t.getParamValue)(\"axis\",r,s,u),l=(0,t.getParamValue)(\"tensors\",r,s,u),c=l[0].shape,o=a.squeeze(l[0]).shape,i=l.map(t=>{const r=e.util.arraysEqual(t.shape,c);if(!r&&!e.util.arraysEqual(a.squeeze(t).shape,o))throw new Error(\"the input tensors shape does not match\");return r?t:a.reshape(t,c)});return[a.stack(i,n)]});case\"Unpack\":{const e=(0,t.getParamValue)(\"axis\",r,s,u),n=(0,t.getParamValue)(\"tensor\",r,s,u);return a.unstack(n,e)}case\"Tile\":{const e=(0,t.getParamValue)(\"reps\",r,s,u);return[a.tile((0,t.getParamValue)(\"x\",r,s,u),e)]}case\"Split\":case\"SplitV\":{const e=(0,t.getParamValue)(\"axis\",r,s,u),n=(0,t.getParamValue)(\"numOrSizeSplits\",r,s,u),l=(0,t.getParamValue)(\"x\",r,s,u);return a.split(l,n,e)}case\"ScatterNd\":{const e=(0,t.getParamValue)(\"indices\",r,s,u),n=(0,t.getParamValue)(\"values\",r,s,u),l=(0,t.getParamValue)(\"shape\",r,s,u);return[a.scatterND(e,n,l)]}case\"GatherNd\":{const e=(0,t.getParamValue)(\"x\",r,s,u),n=(0,t.getParamValue)(\"indices\",r,s,u);return[a.gatherND(e,n)]}case\"SparseToDense\":{const e=(0,t.getParamValue)(\"sparseIndices\",r,s,u),n=(0,t.getParamValue)(\"outputShape\",r,s,u),l=(0,t.getParamValue)(\"sparseValues\",r,s,u),c=(0,t.getParamValue)(\"defaultValue\",r,s,u);return[a.sparseToDense(e,l,n,l.dtype===c.dtype?c:a.cast(c,l.dtype))]}default:throw TypeError(`Node type ${r.op} is not implemented`)}};exports.executeOp=u;const n=\"slice_join\";exports.CATEGORY=n;"},"sourceMaps":null,"error":null,"hash":"c7b74c4170809842fc13bad3c4710397","cacheData":{"env":{}}}