{"id":"o0jj","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"./glsl_version","loc":{"line":17,"column":35},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js"},{"name":"./shader_compiler_util","loc":{"line":18,"column":29},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/encode_matrix_gpu.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.EncodeMatrixProgram=void 0;var e=require(\"./glsl_version\"),t=r(require(\"./shader_compiler_util\"));function n(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return n=function(){return e},e}function r(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=n();if(t&&t.has(e))return t.get(e);var r={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in e)if(Object.prototype.hasOwnProperty.call(e,s)){var l=o?Object.getOwnPropertyDescriptor(e,s):null;l&&(l.get||l.set)?Object.defineProperty(r,s,l):r[s]=e[s]}return r.default=e,t&&t.set(e,r),r}class o{constructor(n,r,o=!1){this.variableNames=[\"A\"];const s=(0,e.getGlslDifferences)(),[l,u]=r;this.outputShape=n;let i=\"result\";o&&(i=\"floor(result * 255. + 0.5)\"),this.userCode=`\\n      ${t.getFlatIndexFrom3D(n)}\\n\\n      void main() {\\n        ivec3 coords = getOutputCoords();\\n\\n        int flatIndex = getFlatIndex(coords);\\n        int offset = imod(flatIndex, 4);\\n\\n        flatIndex = idiv(flatIndex, 4, 1.);\\n\\n        int r = flatIndex / ${u};\\n        int c = imod(flatIndex, ${u});\\n        vec2 uv = (vec2(c, r) + halfCR) / vec2(${u}.0, ${l}.0);\\n        vec4 values = ${s.texture2D}(A, uv);\\n\\n        float result;\\n\\n        if(offset == 0) {\\n          result = values[0];\\n        } else if(offset == 1) {\\n          result = values[1];\\n        } else if(offset == 2) {\\n          result = values[2];\\n        } else {\\n          result = values[3];\\n        }\\n\\n        ${s.output} = vec4(${i}, 0., 0., 0.);\\n      }\\n    `}}exports.EncodeMatrixProgram=o;"},"sourceMaps":null,"error":null,"hash":"03dc6dc3457a5279a5b1a7e4c5f94a1a","cacheData":{"env":{}}}