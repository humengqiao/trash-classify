{"id":"UomO","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-data/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":18,"column":20},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-data/dist/util/deep_map.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.deepMap=n,exports.deepZip=u,exports.zipToList=a,exports.deepMapAndAwaitAll=s,exports.isIterable=c,exports.canTensorify=f;var e=t(require(\"@tensorflow/tfjs-core\"));function r(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return r=function(){return e},e}function t(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=r();if(t&&t.has(e))return t.get(e);var n={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var u in e)if(Object.prototype.hasOwnProperty.call(e,u)){var i=o?Object.getOwnPropertyDescriptor(e,u):null;i&&(i.get||i.set)?Object.defineProperty(n,u,i):n[u]=e[u]}return n.default=e,t&&t.set(e,n),n}function n(e,r){return o(e,r)}function o(e,r,t=new Map,n=new Set){if(null==e)return null;if(n.has(e))throw new Error(\"Circular references are not supported.\");if(t.has(e))return t.get(e);const u=r(e);if(u.recurse&&null!==u.value)throw new Error(\"A deep map function may not return both a value and recurse=true.\");if(u.recurse){if(c(e)){const u=Array.isArray(e)?[]:{};n.add(e);for(const i in e){const a=o(e[i],r,t,n);u[i]=a}return n.delete(e),u}throw new Error(`Can't recurse into non-iterable type: ${e}`)}return t.set(e,u.value),u.value}function u(e,r=a){return i(e,r)}function i(e,r,t=new Set){const n=e[0];if(t.has(n))throw new Error(\"Circular references are not supported.\");const o=r(e);if(o.recurse&&null!==o.value)throw new Error(\"A deep zip function may not return both a value and recurse=true.\");if(o.recurse){if(c(n)){const o=Array.isArray(n)?[]:{};t.add(n);for(const u in n){const n=i(e.map(e=>e[u]),r,t);o[u]=n}return t.delete(n),o}throw new Error(`Can't recurse into non-iterable type: ${n}`)}return o.value}function a(e){return null===e?null:c(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}async function s(r,t){const n=new Map;o(r,t,n);for(const o of Array.from(n.keys())){const r=n.get(o);if(e.util.isPromise(r)){const e=await r;n.set(o,e)}}return o(r,t,n)}function c(r){return null!=r&&!ArrayBuffer.isView(r)&&(Array.isArray(r)||\"object\"==typeof r&&!(r instanceof e.Tensor))}function f(r){return null==r||l(r)||Array.isArray(r)||\"object\"==typeof r&&r instanceof e.Tensor||e.util.isTypedArray(r)}function l(e){return null===e||\"object\"!=typeof e&&\"function\"!=typeof e}"},"sourceMaps":null,"error":null,"hash":"760751058ef645e72ed0b885b002a9e2","cacheData":{"env":{}}}