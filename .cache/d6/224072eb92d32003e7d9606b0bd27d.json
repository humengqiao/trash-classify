{"id":"kOer","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609564004117},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/package.json","includedInParent":true,"mtime":499162500000},{"name":"../ops/complex","loc":{"line":17,"column":24},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/ops/complex.js"},{"name":"../ops/tensor","loc":{"line":18,"column":23},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/ops/tensor.js"},{"name":"../util","loc":{"line":19,"column":30},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/util.js"},{"name":"./types","loc":{"line":20,"column":37},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/io/types.js"},{"name":"buffer","parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/io/io_utils.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/buffer/index.js"}],"generated":{"js":"var Buffer = require(\"buffer\").Buffer;\nvar e=require(\"buffer\").Buffer;Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.encodeWeights=a,exports.decodeWeights=s,exports.concatenateTypedArrays=f,exports.stringByteLength=y,exports.arrayBufferToBase64String=p,exports.base64StringToArrayBuffer=u,exports.concatenateArrayBuffers=c,exports.basename=h,exports.getModelArtifactsInfoForJSON=d,exports.getFloat16Decoder=b;var t=require(\"../ops/complex\"),n=require(\"../ops/tensor\"),r=require(\"../util\"),o=require(\"./types\");const i=4;async function a(e,t){const n=[],r=[],o=Array.isArray(e)?e.map(e=>e.name):Object.keys(e);for(let a=0;a<o.length;++a){const s=o[a],f=Array.isArray(e)?e[a].tensor:e[s];if(\"float32\"!==f.dtype&&\"int32\"!==f.dtype&&\"bool\"!==f.dtype&&\"string\"!==f.dtype&&\"complex64\"!==f.dtype)throw new Error(`Unsupported dtype in weight '${s}': ${f.dtype}`);const l={name:s,shape:f.shape,dtype:f.dtype};if(\"string\"===f.dtype){const e=new Promise(async e=>{const t=await f.bytes(),n=t.reduce((e,t)=>e+t.length,0)+i*t.length,r=new Uint8Array(n);let o=0;for(let a=0;a<t.length;a++){const e=t[a],n=new Uint8Array(new Uint32Array([e.length]).buffer);r.set(n,o),o+=i,r.set(e,o),o+=e.length}e(r)});r.push(e)}else r.push(f.data());null!=t&&(l.group=t),n.push(l)}return{data:f(await Promise.all(r)),specs:n}}function s(e,a){const s={};let f,l=0;for(const y of a){const a=y.name,p=y.dtype,u=y.shape,c=(0,r.sizeFromShape)(u);let h;if(\"quantization\"in y){const t=y.quantization;if(\"uint8\"===t.dtype||\"uint16\"===t.dtype){if(!(\"min\"in t&&\"scale\"in t))throw new Error(`Weight ${y.name} with quantization ${t.dtype} `+\"doesn't have corresponding metadata min and scale.\")}else{if(\"float16\"!==t.dtype)throw new Error(`Weight ${y.name} has unknown `+`quantization dtype ${t.dtype}. `+\"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.\");if(\"float32\"!==p)throw new Error(`Weight ${y.name} is quantized with ${t.dtype} `+`which only supports weights of type float32 not ${p}.`)}const n=o.DTYPE_VALUE_SIZE_MAP[t.dtype],r=e.slice(l,l+c*n),i=\"uint8\"===t.dtype?new Uint8Array(r):new Uint16Array(r);if(\"float32\"===p)if(\"uint8\"===t.dtype||\"uint16\"===t.dtype){h=new Float32Array(i.length);for(let e=0;e<i.length;e++){const n=i[e];h[e]=n*t.scale+t.min}}else{if(\"float16\"!==t.dtype)throw new Error(`Unsupported quantization type ${t.dtype} `+\"for weight type float32.\");void 0===f&&(f=b()),h=f(i)}else{if(\"int32\"!==p)throw new Error(`Unsupported dtype in weight '${a}': ${p}`);if(\"uint8\"!==t.dtype&&\"uint16\"!==t.dtype)throw new Error(`Unsupported quantization type ${t.dtype} `+\"for weight type int32.\");h=new Int32Array(i.length);for(let e=0;e<i.length;e++){const n=i[e];h[e]=Math.round(n*t.scale+t.min)}}l+=c*n}else if(\"string\"===p){const t=(0,r.sizeFromShape)(y.shape);h=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(l,l+i))[0];l+=i;const n=new Uint8Array(e.slice(l,l+t));h.push(n),l+=t}}else{const r=o.DTYPE_VALUE_SIZE_MAP[p],i=e.slice(l,l+c*r);if(\"float32\"===p)h=new Float32Array(i);else if(\"int32\"===p)h=new Int32Array(i);else if(\"bool\"===p)h=new Uint8Array(i);else{if(\"complex64\"!==p)throw new Error(`Unsupported dtype in weight '${a}': ${p}`);{h=new Float32Array(i);const e=new Float32Array(h.length/2),r=new Float32Array(h.length/2);for(let t=0;t<e.length;t++)e[t]=h[2*t],r[t]=h[2*t+1];const o=(0,n.tensor)(e,u,\"float32\"),f=(0,n.tensor)(r,u,\"float32\");s[a]=(0,t.complex)(o,f),o.dispose(),f.dispose()}}l+=c*r}\"complex64\"!==p&&(s[a]=(0,n.tensor)(h,u,p))}return s}function f(e){if(null===e)throw new Error(`Invalid input value: ${JSON.stringify(e)}`);let t=0;const n=[];e.forEach(e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${e.constructor.name}`)});const r=new Uint8Array(t);let o=0;return n.forEach(e=>{r.set(new Uint8Array(e.buffer),o),o+=e.byteLength}),r.buffer}const l=void 0!==e&&(\"undefined\"==typeof Blob||\"undefined\"==typeof atob||\"undefined\"==typeof btoa);function y(t){return l?e.byteLength(t):new Blob([t]).size}function p(t){if(l)return e.from(t).toString(\"base64\");const n=new Uint8Array(t);let r=\"\";for(let e=0,o=n.length;e<o;e++)r+=String.fromCharCode(n[e]);return btoa(r)}function u(t){if(l){const n=e.from(t,\"base64\");return n.buffer.slice(n.byteOffset,n.byteOffset+n.byteLength)}const n=atob(t),r=new Uint8Array(n.length);for(let e=0;e<n.length;++e)r.set([n.charCodeAt(e)],e);return r.buffer}function c(e){if(1===e.length)return e[0];let t=0;e.forEach(e=>{t+=e.byteLength});const n=new Uint8Array(t);let r=0;return e.forEach(e=>{n.set(new Uint8Array(e),r),r+=e.byteLength}),n.buffer}function h(e){for(e=e.trim();e.endsWith(\"/\");)e=e.slice(0,e.length-1);const t=e.split(\"/\");return t[t.length-1]}function d(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error(\"Expected JSON model topology, received ArrayBuffer.\");return{dateSaved:new Date,modelTopologyType:\"JSON\",modelTopologyBytes:null==e.modelTopology?0:y(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:y(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function w(){const e=e=>{let t=e<<13,n=0;for(;0==(8388608&t);)n-=8388608,t<<=1;return(t&=-8388609)|(n+=947912704)},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}function g(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}function A(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}function b(){const e=w(),t=g(),n=A();return r=>{const o=new ArrayBuffer(4*r.length),i=new Uint32Array(o);for(let a=0;a<r.length;a++){const o=r[a],s=e[n[o>>10]+(1023&o)]+t[o>>10];i[a]=s}return new Float32Array(o)}}"},"sourceMaps":null,"error":null,"hash":"260994faacf5d5d5ed8e714b8282ac1f","cacheData":{"env":{}}}