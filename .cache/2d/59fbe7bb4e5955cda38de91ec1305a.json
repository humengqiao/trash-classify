{"id":"viLo","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609563696417},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.Conv3DProgram=exports.Conv2DProgram=void 0;class n{constructor(n,t=!1,e=null,o=!1){this.variableNames=[\"x\",\"W\"],this.outputShape=n.outShape;const d=n.padInfo.top,i=n.padInfo.left,a=n.strideHeight,s=n.strideWidth,x=n.dilationHeight,r=n.dilationWidth,c=n.filterHeight,C=n.filterWidth,l=4*Math.floor(n.inChannels/4),w=n.inChannels%4,h=\"channelsLast\"===n.dataFormat,R=h?1:2,$=h?2:3,u=h?3:1;let g=\"\",v=\"\";e&&(g=o?`float activation(float a) {\\n          float b = getPreluActivationWeightsAtOutCoords();\\n          ${e}\\n        }`:`\\n          float activation(float x) {\\n            ${e}\\n          }\\n        `,v=\"result = activation(result);\");const f=t?\"result += getBiasAtOutCoords();\":\"\";t&&this.variableNames.push(\"bias\"),o&&this.variableNames.push(\"preluActivationWeights\"),this.userCode=`\\n      ${g}\\n\\n      const ivec2 strides = ivec2(${a}, ${s});\\n      const ivec2 pads = ivec2(${d}, ${i});\\n\\n      void main() {\\n        ivec4 coords = getOutputCoords();\\n        int batch = coords[0];\\n        int d2 = coords[${u}];\\n\\n        ivec2 xRCCorner =\\n            ivec2(coords[${R}], coords[${$}]) * strides - pads;\\n        int xRCorner = xRCCorner.x;\\n        int xCCorner = xRCCorner.y;\\n\\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\\n        // ? = to be determined. : = across all values in that axis.\\n        float dotProd = 0.0;\\n        for (int wR = 0; wR < ${c}; wR++) {\\n          int xR = xRCorner + wR * ${x};\\n\\n          if (xR < 0 || xR >= ${n.inHeight}) {\\n            continue;\\n          }\\n\\n          for (int wC = 0; wC < ${C}; wC++) {\\n            int xC = xCCorner + wC * ${r};\\n\\n            if (xC < 0 || xC >= ${n.inWidth}) {\\n              continue;\\n            }\\n\\n            for (int d1 = 0; d1 < ${l}; d1 += 4) {\\n              vec4 wValues = vec4(\\n                getW(wR, wC, d1, d2),\\n                getW(wR, wC, d1 + 1, d2),\\n                getW(wR, wC, d1 + 2, d2),\\n                getW(wR, wC, d1 + 3, d2)\\n              );\\n\\n              if (${h}) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xR, xC, d1),\\n                  getX(batch, xR, xC, d1 + 1),\\n                  getX(batch, xR, xC, d1 + 2),\\n                  getX(batch, xR, xC, d1 + 3)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec4 xValues = vec4(\\n                  getX(batch, d1, xR, xC),\\n                  getX(batch, d1 + 1, xR, xC),\\n                  getX(batch, d1 + 2, xR, xC),\\n                  getX(batch, d1 + 3, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n\\n            if (${1===w}) {\\n\\n              if (${h}) {\\n                dotProd +=\\n                    getX(batch, xR, xC, ${l}) *\\n                    getW(wR, wC, ${l}, d2);\\n              } else {\\n                dotProd +=\\n                    getX(batch, ${l}, xR, xC) *\\n                    getW(wR, wC, ${l}, d2);\\n              }\\n\\n            } else if (${2===w}) {\\n              vec2 wValues = vec2(\\n                getW(wR, wC, ${l}, d2),\\n                getW(wR, wC, ${l} + 1, d2)\\n              );\\n\\n              if (${h}) {\\n                vec2 xValues = vec2(\\n                  getX(batch, xR, xC, ${l}),\\n                  getX(batch, xR, xC, ${l} + 1)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec2 xValues = vec2(\\n                  getX(batch, ${l}, xR, xC),\\n                  getX(batch, ${l} + 1, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            } else if (${3===w}) {\\n              vec3 wValues = vec3(\\n                getW(wR, wC, ${l}, d2),\\n                getW(wR, wC, ${l} + 1, d2),\\n                getW(wR, wC, ${l} + 2, d2)\\n              );\\n\\n              if (${h}) {\\n                vec3 xValues = vec3(\\n                  getX(batch, xR, xC, ${l}),\\n                  getX(batch, xR, xC, ${l} + 1),\\n                  getX(batch, xR, xC, ${l} + 2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else {\\n                vec3 xValues = vec3(\\n                  getX(batch, ${l}, xR, xC),\\n                  getX(batch, ${l} + 1, xR, xC),\\n                  getX(batch, ${l} + 2, xR, xC)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n            }\\n          }\\n        }\\n\\n        float result = dotProd;\\n        ${f}\\n        ${v}\\n        setOutput(result);\\n      }\\n    `}}exports.Conv2DProgram=n;class t{constructor(n){this.variableNames=[\"x\",\"W\"],this.outputShape=n.outShape;const t=n.padInfo.front,e=n.padInfo.top,o=n.padInfo.left,d=n.strideDepth,i=n.strideHeight,a=n.strideWidth,s=n.dilationDepth,x=n.dilationHeight,r=n.dilationWidth,c=n.filterDepth,C=n.filterHeight,l=n.filterWidth,w=4*Math.floor(n.inChannels/4),h=n.inChannels%4;this.userCode=`\\n      const ivec3 strides = ivec3(${d}, ${i}, ${a});\\n      const ivec3 pads = ivec3(${t}, ${e}, ${o});\\n\\n      void main() {\\n        ivec5 coords = getOutputCoords();\\n        int batch = coords.x;\\n        int d2 = coords.u;\\n\\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\\n        int xFCorner = xFRCCorner.x;\\n        int xRCorner = xFRCCorner.y;\\n        int xCCorner = xFRCCorner.z;\\n\\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\\n        // values in that axis.\\n        float dotProd = 0.0;\\n        for (int wF = 0; wF < ${c}; wF++) {\\n          int xF = xFCorner + wF * ${s};\\n\\n          if (xF < 0 || xF >= ${n.inDepth}) {\\n            continue;\\n          }\\n\\n          for (int wR = 0; wR < ${C}; wR++) {\\n            int xR = xRCorner + wR * ${x};\\n\\n            if (xR < 0 || xR >= ${n.inHeight}) {\\n              continue;\\n            }\\n\\n            for (int wC = 0; wC < ${l}; wC++) {\\n              int xC = xCCorner + wC * ${r};\\n\\n              if (xC < 0 || xC >= ${n.inWidth}) {\\n                continue;\\n              }\\n\\n              for (int d1 = 0; d1 < ${w}; d1 += 4) {\\n                vec4 xValues = vec4(\\n                  getX(batch, xF, xR, xC, d1),\\n                  getX(batch, xF, xR, xC, d1 + 1),\\n                  getX(batch, xF, xR, xC, d1 + 2),\\n                  getX(batch, xF, xR, xC, d1 + 3)\\n                );\\n                vec4 wValues = vec4(\\n                  getW(wF, wR, wC, d1, d2),\\n                  getW(wF, wR, wC, d1 + 1, d2),\\n                  getW(wF, wR, wC, d1 + 2, d2),\\n                  getW(wF, wR, wC, d1 + 3, d2)\\n                );\\n\\n                dotProd += dot(xValues, wValues);\\n              }\\n\\n              if (${1===h}) {\\n                dotProd +=\\n                  getX(batch, xF, xR, xC, ${w}) *\\n                  getW(wF, wR, wC, ${w}, d2);\\n              } else if (${2===h}) {\\n                vec2 xValues = vec2(\\n                  getX(batch, xF, xR, xC, ${w}),\\n                  getX(batch, xF, xR, xC, ${w} + 1)\\n                );\\n                vec2 wValues = vec2(\\n                  getW(wF, wR, wC, ${w}, d2),\\n                  getW(wF, wR, wC, ${w} + 1, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              } else if (${3===h}) {\\n                vec3 xValues = vec3(\\n                  getX(batch, xF, xR, xC, ${w}),\\n                  getX(batch, xF, xR, xC, ${w} + 1),\\n                  getX(batch, xF, xR, xC, ${w} + 2)\\n                );\\n                vec3 wValues = vec3(\\n                  getW(wF, wR, wC, ${w}, d2),\\n                  getW(wF, wR, wC, ${w} + 1, d2),\\n                  getW(wF, wR, wC, ${w} + 2, d2)\\n                );\\n                dotProd += dot(xValues, wValues);\\n              }\\n            }\\n          }\\n        }\\n        setOutput(dotProd);\\n      }\\n    `}}exports.Conv3DProgram=t;"},"sourceMaps":null,"error":null,"hash":"a9326bc383e22436021740340c807c4a","cacheData":{"env":{}}}