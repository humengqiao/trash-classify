{"id":"xhhc","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":17,"column":35},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"./glsl_version","loc":{"line":19,"column":35},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/glsl_version.js"},{"name":"./shader_compiler_util","loc":{"line":20,"column":29},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-backend-webgl/dist/shader_compiler_util.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.makeShader=c,exports.getCoordsDataType=W;var n=require(\"@tensorflow/tfjs-core\"),e=require(\"./glsl_version\"),t=o(require(\"./shader_compiler_util\"));function r(){if(\"function\"!=typeof WeakMap)return null;var n=new WeakMap;return r=function(){return n},n}function o(n){if(n&&n.__esModule)return n;if(null===n||\"object\"!=typeof n&&\"function\"!=typeof n)return{default:n};var e=r();if(e&&e.has(n))return e.get(n);var t={},o=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in n)if(Object.prototype.hasOwnProperty.call(n,i)){var c=o?Object.getOwnPropertyDescriptor(n,i):null;c&&(c.get||c.set)?Object.defineProperty(t,i,c):t[i]=n[i]}return t.default=n,e&&e.set(n,t),t}const{getBroadcastDims:i}=n.backend_util;function c(t,r,o,i){const c=[];t.forEach(e=>{const t=n.util.sizeFromShape(e.shapeInfo.logicalShape);e.shapeInfo.isUniform?c.push(`uniform float ${e.name}${t>1?`[${t}]`:\"\"};`):(c.push(`uniform sampler2D ${e.name};`),c.push(`uniform int offset${e.name};`))});const u=c.join(\"\\n\"),l=t.map(n=>a(n,r,i)).join(\"\\n\"),f=r.texShape,v=(0,e.getGlslDifferences)(),g=$(v);let m,w,R=x(v);return r.isPacked?(m=s(r.logicalShape,f),w=h(v)):(m=p(r.logicalShape,f),w=d(v)),i&&(R+=C),[R,g,w,u,m,l,o].join(\"\\n\")}function u(n){const e=n.shapeInfo.logicalShape;switch(e.length){case 0:return N(n);case 1:return k(n);case 2:return j(n);case 3:return E(n);case 4:return L(n);case 5:return P(n);case 6:return _(n);default:throw new Error(`${e.length}-D input sampling`+\" is not yet supported\")}}function l(n){switch(n.shapeInfo.logicalShape.length){case 0:return M(n);case 1:return F(n);case 2:return A(n);case 3:return z(n);default:return q(n)}}function a(n,e,t=!1){let r=\"\";r+=t?l(n):u(n);const o=n.shapeInfo.logicalShape,i=e.logicalShape;return o.length<=i.length&&(r+=t?H(n,e):B(n,e)),r}function s(n,e){switch(n.length){case 0:return m();case 1:return w(n,e);case 2:return V(n,e);case 3:return y(n,e);default:return I(n,e)}}function p(n,e){switch(n.length){case 0:return m();case 1:return R(n,e);case 2:return D(n,e);case 3:return S(n,e);case 4:return T(n,e);case 5:return U(n,e);case 6:return O(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function $(n){return`\\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\\n      return ${n.texture2D}(textureSampler, uv).r;\\n    }\\n  `}function d(n){return`\\n    void setOutput(float val) {\\n      ${n.output} = vec4(val, 0, 0, 0);\\n    }\\n  `}function h(n){return`\\n    void setOutput(vec4 val) {\\n      ${n.output} = val;\\n    }\\n  `}function x(n){return`${n.version}\\n    precision highp float;\\n    precision highp int;\\n    precision highp sampler2D;\\n    ${n.varyingFs} vec2 resultUV;\\n    ${n.defineOutput}\\n    const vec2 halfCR = vec2(0.5, 0.5);\\n\\n    struct ivec5\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n    };\\n\\n    struct ivec6\\n    {\\n      int x;\\n      int y;\\n      int z;\\n      int w;\\n      int u;\\n      int v;\\n    };\\n\\n    uniform float NAN;\\n    ${n.defineSpecialNaN}\\n    ${n.defineSpecialInf}\\n    ${n.defineRound}\\n\\n    int imod(int x, int y) {\\n      return x - y * (x / y);\\n    }\\n\\n    int idiv(int a, int b, float sign) {\\n      int res = a / b;\\n      int mod = imod(a, b);\\n      if (sign < 0. && mod != 0) {\\n        res -= 1;\\n      }\\n      return res;\\n    }\\n\\n    //Based on the work of Dave Hoskins\\n    //https://www.shadertoy.com/view/4djSRW\\n    #define HASHSCALE1 443.8975\\n    float random(float seed){\\n      vec2 p = resultUV * seed;\\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n      p3 += dot(p3, p3.yzx + 19.19);\\n      return fract((p3.x + p3.y) * p3.z);\\n    }\\n\\n    ${f}\\n    ${v}\\n    ${g}\\n  `}const f=\"\\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\\n  int texelIndex = index / 2;\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",v=\"\\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\\n  int texNumC, int row, int col) {\\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = texelIndex / texNumC;\\n  int texC = texelIndex - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",g=\"\\nvec2 packedUVfrom3D(int texNumR, int texNumC,\\n    int texelsInBatch, int texelsInLogicalRow, int b,\\n    int row, int col) {\\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\\n  int texR = index / texNumC;\\n  int texC = index - texR * texNumC;\\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\\n}\\n\",C=\"\\n  float getChannel(vec4 frag, vec2 innerDims) {\\n    vec2 modCoord = mod(innerDims, 2.);\\n    return modCoord.x == 0. ?\\n      (modCoord.y == 0. ? frag.r : frag.g) :\\n      (modCoord.y == 0. ? frag.b : frag.a);\\n  }\\n  float getChannel(vec4 frag, int dim) {\\n    float modCoord = mod(float(dim), 2.);\\n    return modCoord == 0. ? frag.r : frag.g;\\n  }\\n\";function m(){return\"\\n    int getOutputCoords() {\\n      return 0;\\n    }\\n  \"}function w(n,e){const t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return 1===t[0]?`\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.x * ${t[1]}.0);\\n      }\\n    `:1===t[1]?`\\n      int getOutputCoords() {\\n        return 2 * int(resultUV.y * ${t[0]}.0);\\n      }\\n    `:`\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${t[0]}, ${t[1]}));\\n      return 2 * (resTexRC.x * ${t[1]} + resTexRC.y);\\n    }\\n  `}function R(n,e){return 1===e[0]?`\\n      int getOutputCoords() {\\n        return int(resultUV.x * ${e[1]}.0);\\n      }\\n    `:1===e[1]?`\\n      int getOutputCoords() {\\n        return int(resultUV.y * ${e[0]}.0);\\n      }\\n    `:`\\n    int getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${e[0]}, ${e[1]}));\\n      return resTexRC.x * ${e[1]} + resTexRC.y;\\n    }\\n  `}function y(n,e){const t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[2]/2),o=r*Math.ceil(n[1]/2);return`\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${t[0]}, ${t[1]}));\\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\\n\\n      int b = index / ${o};\\n      index -= b * ${o};\\n\\n      int r = 2 * (index / ${r});\\n      int c = imod(index, ${r}) * 2;\\n\\n      return ivec3(b, r, c);\\n    }\\n  `}function S(n,e){const r=t.getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\"],n);return`\\n    ivec3 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${e[0]}, ${e[1]}));\\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\\n      ${r}\\n      return ivec3(r, c, d);\\n    }\\n  `}function I(n,e){const t=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],r=Math.ceil(n[n.length-1]/2),o=r*Math.ceil(n[n.length-2]/2);let i=o,c=\"\",u=\"b, r, c\";for(let l=2;l<n.length-1;l++)c=`\\n      int b${l} = index / ${i*=n[n.length-l-1]};\\n      index -= b${l} * ${i};\\n    `+c,u=`b${l}, `+u;return`\\n    ivec${n.length} getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${t[0]}, ${t[1]}));\\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\\n\\n      ${c}\\n\\n      int b = index / ${o};\\n      index -= b * ${o};\\n\\n      int r = 2 * (index / ${r});\\n      int c = imod(index, ${r}) * 2;\\n\\n      return ivec${n.length}(${u});\\n    }\\n  `}function T(n,e){const r=t.getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\",\"d2\"],n);return`\\n    ivec4 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(${e[0]}, ${e[1]}));\\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\\n      ${r}\\n      return ivec4(r, c, d, d2);\\n    }\\n  `}function U(n,e){const r=t.getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\",\"d2\",\"d3\"],n);return`\\n    ivec5 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},\\n                             ${e[1]}));\\n\\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\\n\\n      ${r}\\n\\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\\n      return outShape;\\n    }\\n  `}function O(n,e){const r=t.getLogicalCoordinatesFromFlatIndex([\"r\",\"c\",\"d\",\"d2\",\"d3\",\"d4\"],n);return`\\n    ivec6 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n        vec2(${e[0]}, ${e[1]}));\\n      int index = resTexRC.x * ${e[1]} + resTexRC.y;\\n\\n      ${r}\\n\\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\\n      return result;\\n    }\\n  `}function V(e,t){const r=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(n.util.arraysEqual(e,t))return`\\n      ivec2 getOutputCoords() {\\n        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));\\n      }\\n    `;const o=Math.ceil(e[1]/2);return`\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${r[0]}, ${r[1]}));\\n\\n      int index = resTexRC.x * ${r[1]} + resTexRC.y;\\n      int r = 2 * (index / ${o});\\n      int c = imod(index, ${o}) * 2;\\n\\n      return ivec2(r, c);\\n    }\\n  `}function D(e,t){return n.util.arraysEqual(e,t)?`\\n      ivec2 getOutputCoords() {\\n        return ivec2(resultUV.yx * vec2(${t[0]}, ${t[1]}));\\n      }\\n    `:1===e[1]?`\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(${t[0]}, ${t[1]}));\\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\\n        return ivec2(index, 0);\\n      }\\n    `:1===e[0]?`\\n      ivec2 getOutputCoords() {\\n        ivec2 resTexRC = ivec2(resultUV.yx *\\n                               vec2(${t[0]}, ${t[1]}));\\n        int index = resTexRC.x * ${t[1]} + resTexRC.y;\\n        return ivec2(0, index);\\n      }\\n    `:`\\n    ivec2 getOutputCoords() {\\n      ivec2 resTexRC = ivec2(resultUV.yx *\\n                             vec2(${t[0]}, ${t[1]}));\\n      int index = resTexRC.x * ${t[1]} + resTexRC.y;\\n      int r = index / ${e[1]};\\n      int c = index - r * ${e[1]};\\n      return ivec2(r, c);\\n    }\\n  `}function b(n){return`offset${n}`}function M(n){const t=n.name;return`\\n    vec4 ${\"get\"+t.charAt(0).toUpperCase()+t.slice(1)}() {\\n      return ${(0,e.getGlslDifferences)().texture2D}(${t}, halfCR);\\n    }\\n  `}function N(n){const e=n.name,t=\"get\"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`float ${t}() {return ${e};}`;const[r,o]=n.shapeInfo.texShape;if(1===r&&1===o)return`\\n      float ${t}() {\\n        return sampleTexture(${e}, halfCR);\\n      }\\n    `;const[i,c]=n.shapeInfo.texShape;return`\\n    float ${t}() {\\n      vec2 uv = uvFromFlat(${i}, ${c}, ${b(e)});\\n      return sampleTexture(${e}, uv);\\n    }\\n  `}function F(n){const t=n.name,r=\"get\"+t.charAt(0).toUpperCase()+t.slice(1),o=n.shapeInfo.texShape,i=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],c=(0,e.getGlslDifferences)();return`\\n    vec4 ${r}(int index) {\\n      vec2 uv = packedUVfrom1D(\\n        ${i[0]}, ${i[1]}, index);\\n      return ${c.texture2D}(${t}, uv);\\n    }\\n  `}function k(n){const e=n.name,t=\"get\"+e.charAt(0).toUpperCase()+e.slice(1);if(n.shapeInfo.isUniform)return`\\n      float ${t}(int index) {\\n        ${G(n)}\\n      }\\n    `;const r=n.shapeInfo.texShape,o=r[0],i=r[1];if(1===i&&1===o)return`\\n      float ${t}(int index) {\\n        return sampleTexture(${e}, halfCR);\\n      }\\n    `;const c=b(e);return 1===i?`\\n      float ${t}(int index) {\\n        vec2 uv = vec2(0.5, (float(index + ${c}) + 0.5) / ${o}.0);\\n        return sampleTexture(${e}, uv);\\n      }\\n    `:1===o?`\\n      float ${t}(int index) {\\n        vec2 uv = vec2((float(index + ${c}) + 0.5) / ${i}.0, 0.5);\\n        return sampleTexture(${e}, uv);\\n      }\\n    `:`\\n    float ${t}(int index) {\\n      vec2 uv = uvFromFlat(${o}, ${i}, index + ${c});\\n      return sampleTexture(${e}, uv);\\n    }\\n  `}function A(t){const r=t.shapeInfo.logicalShape,o=t.name,i=\"get\"+o.charAt(0).toUpperCase()+o.slice(1),c=t.shapeInfo.texShape,u=c[0],l=c[1],a=(0,e.getGlslDifferences)();if(null!=c&&n.util.arraysEqual(r,c))return`\\n      vec4 ${i}(int row, int col) {\\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${u}.0);\\n\\n        return ${a.texture2D}(${o}, uv);\\n      }\\n    `;const s=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];return`\\n    vec4 ${i}(int row, int col) {\\n      vec2 uv = packedUVfrom2D(${Math.ceil(r[1]/2)}, ${s[0]}, ${s[1]}, row, col);\\n      return ${a.texture2D}(${o}, uv);\\n    }\\n  `}function j(e){const t=e.shapeInfo.logicalShape,r=e.name,o=\"get\"+r.charAt(0).toUpperCase()+r.slice(1),i=e.shapeInfo.texShape;if(null!=i&&n.util.arraysEqual(t,i)){const n=i[0];return`\\n    float ${o}(int row, int col) {\\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(${i[1]}.0, ${n}.0);\\n      return sampleTexture(${r}, uv);\\n    }\\n  `}const{newShape:c,keptDims:l}=n.util.squeezeShape(t),a=c;if(a.length<t.length){const n=[\"row\",\"col\"];return`\\n      ${u(J(e,a))}\\n      float ${o}(int row, int col) {\\n        return ${o}(${K(n,l)});\\n      }\\n    `}if(e.shapeInfo.isUniform)return`\\n      float ${o}(int row, int col) {\\n        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));\\n        ${G(e)}\\n      }\\n    `;const s=i[0],p=i[1],$=b(r);return 1===p?`\\n    float ${o}(int row, int col) {\\n      float index = dot(vec3(row, col, ${$}), vec3(${t[1]}, 1, 1));\\n      vec2 uv = vec2(0.5, (index + 0.5) / ${s}.0);\\n      return sampleTexture(${r}, uv);\\n    }\\n  `:1===s?`\\n    float ${o}(int row, int col) {\\n      float index = dot(vec3(row, col, ${$}), vec3(${t[1]}, 1, 1));\\n      vec2 uv = vec2((index + 0.5) / ${p}.0, 0.5);\\n      return sampleTexture(${r}, uv);\\n    }\\n  `:`\\n  float ${o}(int row, int col) {\\n    // Explicitly use integer operations as dot() only works on floats.\\n    int index = row * ${t[1]} + col + ${$};\\n    vec2 uv = uvFromFlat(${s}, ${p}, index);\\n    return sampleTexture(${r}, uv);\\n  }\\n`}function z(n){const t=n.shapeInfo.logicalShape,r=n.name,o=\"get\"+r.charAt(0).toUpperCase()+r.slice(1),i=n.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];if(1===t[0]){const e=[1,2],r=[\"b\",\"row\",\"col\"];return`\\n        ${l(J(n,t.slice(1)))}\\n        vec4 ${o}(int b, int row, int col) {\\n          return ${o}(${K(r,e)});\\n        }\\n      `}const u=c[0],a=c[1],s=Math.ceil(t[2]/2);return`\\n    vec4 ${o}(int b, int row, int col) {\\n      vec2 uv = packedUVfrom3D(\\n        ${u}, ${a}, ${s*Math.ceil(t[1]/2)}, ${s}, b, row, col);\\n      return ${(0,e.getGlslDifferences)().texture2D}(${r}, uv);\\n    }\\n  `}function E(e){const t=e.shapeInfo.logicalShape,r=e.name,o=\"get\"+r.charAt(0).toUpperCase()+r.slice(1),i=t[1]*t[2],c=t[2],{newShape:l,keptDims:a}=n.util.squeezeShape(t),s=l;if(s.length<t.length){const n=[\"row\",\"col\",\"depth\"];return`\\n        ${u(J(e,s))}\\n        float ${o}(int row, int col, int depth) {\\n          return ${o}(${K(n,a)});\\n        }\\n      `}if(e.shapeInfo.isUniform)return`\\n      float ${o}(int row, int col, int depth) {\\n        int index = round(dot(vec3(row, col, depth),\\n                          vec3(${i}, ${c}, 1)));\\n        ${G(e)}\\n      }\\n    `;const p=e.shapeInfo.texShape,$=p[0],d=p[1],h=e.shapeInfo.flatOffset;return d===i&&null==h?`\\n        float ${o}(int row, int col, int depth) {\\n          float texR = float(row);\\n          float texC = dot(vec2(col, depth), vec2(${c}, 1));\\n          vec2 uv = (vec2(texC, texR) + halfCR) /\\n                     vec2(${d}.0, ${$}.0);\\n          return sampleTexture(${r}, uv);\\n        }\\n      `:d===c&&null==h?`\\n    float ${o}(int row, int col, int depth) {\\n      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));\\n      float texC = float(depth);\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${$}.0);\\n      return sampleTexture(${r}, uv);\\n    }\\n  `:`\\n      float ${o}(int row, int col, int depth) {\\n        // Explicitly use integer operations as dot() only works on floats.\\n        int index = row * ${i} + col * ${c} + depth + ${b(r)};\\n        vec2 uv = uvFromFlat(${$}, ${d}, index);\\n        return sampleTexture(${r}, uv);\\n      }\\n  `}function q(n){const t=n.shapeInfo.logicalShape,r=t.length,o=n.name,i=\"get\"+o.charAt(0).toUpperCase()+o.slice(1),c=n.shapeInfo.texShape,u=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)],l=u[0],a=u[1],s=Math.ceil(t[r-1]/2);let p=s*Math.ceil(t[r-2]/2),$=\"int b, int row, int col\",d=`b * ${p} + (row / 2) * ${s} + (col / 2)`;for(let e=2;e<r-1;e++)$=`int b${e}, `+$,d=`b${e} * ${p*=t[r-e-1]} + `+d;return`\\n    vec4 ${i}(${$}) {\\n      int index = ${d};\\n      int texR = index / ${a};\\n      int texC = index - texR * ${a};\\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${a}, ${l});\\n      return ${(0,e.getGlslDifferences)().texture2D}(${o}, uv);\\n    }\\n  `}function L(e){const t=e.shapeInfo.logicalShape,r=e.name,o=\"get\"+r.charAt(0).toUpperCase()+r.slice(1),i=t[3],c=t[2]*i,l=t[1]*c,{newShape:a,keptDims:s}=n.util.squeezeShape(t);if(a.length<t.length){const n=[\"row\",\"col\",\"depth\",\"depth2\"];return`\\n      ${u(J(e,a))}\\n      float ${o}(int row, int col, int depth, int depth2) {\\n        return ${o}(${K(n,s)});\\n      }\\n    `}if(e.shapeInfo.isUniform)return`\\n      float ${o}(int row, int col, int depth, int depth2) {\\n        int index = round(dot(vec4(row, col, depth, depth2),\\n                          vec4(${l}, ${c}, ${i}, 1)));\\n        ${G(e)}\\n      }\\n    `;const p=e.shapeInfo.flatOffset,$=e.shapeInfo.texShape,d=$[0],h=$[1];return h===l&&null==p?`\\n      float ${o}(int row, int col, int depth, int depth2) {\\n        float texR = float(row);\\n        float texC =\\n            dot(vec3(col, depth, depth2),\\n                vec3(${c}, ${i}, 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(${h}.0, ${d}.0);\\n        return sampleTexture(${r}, uv);\\n      }\\n    `:h===i&&null==p?`\\n      float ${o}(int row, int col, int depth, int depth2) {\\n        float texR = dot(vec3(row, col, depth),\\n                         vec3(${t[1]*t[2]}, ${t[2]}, 1));\\n        float texC = float(depth2);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(${h}.0, ${d}.0);\\n        return sampleTexture(${r}, uv);\\n      }\\n    `:`\\n    float ${o}(int row, int col, int depth, int depth2) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * ${l} + col * ${c} +\\n          depth * ${i} + depth2;\\n      vec2 uv = uvFromFlat(${d}, ${h}, index + ${b(r)});\\n      return sampleTexture(${r}, uv);\\n    }\\n  `}function P(e){const t=e.shapeInfo.logicalShape,r=e.name,o=\"get\"+r.charAt(0).toUpperCase()+r.slice(1),i=t[4],c=t[3]*i,l=t[2]*c,a=t[1]*l,{newShape:s,keptDims:p}=n.util.squeezeShape(t);if(s.length<t.length){const n=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\"];return`\\n      ${u(J(e,s))}\\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\\n        return ${o}(${K(n,p)});\\n      }\\n    `}if(e.shapeInfo.isUniform)return`\\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\\n        float index = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(${a}, ${l}, ${c}, ${i})) +\\n          depth3;\\n        ${G(e)}\\n      }\\n    `;const $=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,h=d[0],x=d[1];return x===a&&null==$?`\\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n                         vec4(${l}, ${c}, ${i}, 1));\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(${x}.0, ${h}.0);\\n        return sampleTexture(${r}, uv);\\n      }\\n    `:x===i&&null==$?`\\n      float ${o}(int row, int col, int depth, int depth2, int depth3) {\\n        float texR = dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(${t[1]*t[2]*t[3]},\\n               ${t[2]*t[3]}, ${t[3]}, 1));\\n        int texC = depth3;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(${x}.0, ${h}.0);\\n        return sampleTexture(${r}, uv);\\n      }\\n    `:`\\n    float ${o}(int row, int col, int depth, int depth2, int depth3) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * ${a} + col * ${l} + depth * ${c} +\\n          depth2 * ${i} + depth3 + ${b(r)};\\n      vec2 uv = uvFromFlat(${h}, ${x}, index);\\n      return sampleTexture(${r}, uv);\\n    }\\n  `}function _(e){const t=e.shapeInfo.logicalShape,r=e.name,o=\"get\"+r.charAt(0).toUpperCase()+r.slice(1),{newShape:i,keptDims:c}=n.util.squeezeShape(t);if(i.length<t.length){const n=[\"row\",\"col\",\"depth\",\"depth2\",\"depth3\",\"depth4\"];return`\\n      ${u(J(e,i))}\\n      float ${o}(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        return ${o}(${K(n,c)});\\n      }\\n    `}const l=t[5],a=t[4]*l,s=t[3]*a,p=t[2]*s,$=t[1]*p;if(e.shapeInfo.isUniform)return`\\n      float ${o}(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n        int index = round(dot(\\n          vec4(row, col, depth, depth2),\\n          vec4(${$}, ${p}, ${s}, ${a})) +\\n          dot(\\n            vec2(depth3, depth4),\\n            vec2(${l}, 1)));\\n        ${G(e)}\\n      }\\n    `;const d=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,x=h[0],f=h[1];return f===$&&null==d?`\\n      float ${o}(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        int texR = row;\\n        float texC = dot(vec4(col, depth, depth2, depth3),\\n          vec4(${p}, ${s}, ${a}, ${l})) +\\n               float(depth4);\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                   vec2(${f}.0, ${x}.0);\\n        return sampleTexture(${r}, uv);\\n      }\\n    `:f===l&&null==d?`\\n      float ${o}(int row, int col, int depth,\\n                    int depth2, int depth3, int depth4) {\\n        float texR = dot(vec4(row, col, depth, depth2),\\n          vec4(${t[1]*t[2]*t[3]*t[4]},\\n               ${t[2]*t[3]*t[4]},\\n               ${t[3]*t[4]},\\n               ${t[4]})) + float(depth3);\\n        int texC = depth4;\\n        vec2 uv = (vec2(texC, texR) + halfCR) /\\n                  vec2(${f}.0, ${x}.0);\\n        return sampleTexture(${r}, uv);\\n      }\\n    `:`\\n    float ${o}(int row, int col, int depth,\\n                  int depth2, int depth3, int depth4) {\\n      // Explicitly use integer operations as dot() only works on floats.\\n      int index = row * ${$} + col * ${p} + depth * ${s} +\\n          depth2 * ${a} + depth3 * ${l} + depth4 + ${b(r)};\\n      vec2 uv = uvFromFlat(${x}, ${f}, index);\\n      return sampleTexture(${r}, uv);\\n    }\\n  `}function G(e){const t=e.name,r=n.util.sizeFromShape(e.shapeInfo.logicalShape);return r<2?`return ${t};`:`\\n    for (int i = 0; i < ${r}; i++) {\\n      if (i == index) {\\n        return ${t}[i];\\n      }\\n    }\\n  `}function H(e,t){const r=e.name,o=r.charAt(0).toUpperCase()+r.slice(1),c=\"get\"+o+\"AtOutCoords\",u=e.shapeInfo.logicalShape.length,l=t.logicalShape.length,a=i(e.shapeInfo.logicalShape,t.logicalShape),s=W(l),p=l-u;let $;const d=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];$=0===u?\"\":l<2&&a.length>=1?\"coords = 0;\":a.map(n=>`coords.${d[n+p]} = 0;`).join(\"\\n\");let h=\"\";h=l<2&&u>0?\"coords\":e.shapeInfo.logicalShape.map((n,e)=>`coords.${d[e+p]}`).join(\", \");let x=\"return outputValue;\";const f=1===n.util.sizeFromShape(e.shapeInfo.logicalShape),v=1===n.util.sizeFromShape(t.logicalShape);if(1!==u||f||v){if(f&&!v)x=1===l?\"\\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\\n      \":\"\\n        return vec4(outputValue.x);\\n      \";else if(a.length){const n=u-2,e=u-1;a.indexOf(n)>-1&&a.indexOf(e)>-1?x=\"return vec4(outputValue.x);\":a.indexOf(n)>-1?x=\"return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);\":a.indexOf(e)>-1&&(x=\"return vec4(outputValue.xx, outputValue.zz);\")}}else x=\"\\n      return vec4(outputValue.xy, outputValue.xy);\\n    \";return`\\n    vec4 ${c}() {\\n      ${s} coords = getOutputCoords();\\n      ${$}\\n      vec4 outputValue = get${o}(${h});\\n      ${x}\\n    }\\n  `}function B(e,t){const r=e.name,o=r.charAt(0).toUpperCase()+r.slice(1),c=\"get\"+o+\"AtOutCoords\",u=t.texShape,l=e.shapeInfo.texShape,a=e.shapeInfo.logicalShape.length,s=t.logicalShape.length;if(!e.shapeInfo.isUniform&&a===s&&null==e.shapeInfo.flatOffset&&n.util.arraysEqual(l,u))return`\\n      float ${c}() {\\n        return sampleTexture(${r}, resultUV);\\n      }\\n    `;const p=W(s),$=i(e.shapeInfo.logicalShape,t.logicalShape),d=s-a;let h;const x=[\"x\",\"y\",\"z\",\"w\",\"u\",\"v\"];let f=\"\";return`\\n    float ${c}() {\\n      ${p} coords = getOutputCoords();\\n      ${h=0===a?\"\":s<2&&$.length>=1?\"coords = 0;\":$.map(n=>`coords.${x[n+d]} = 0;`).join(\"\\n\")}\\n      return get${o}(${f=s<2&&a>0?\"coords\":e.shapeInfo.logicalShape.map((n,e)=>`coords.${x[e+d]}`).join(\", \")});\\n    }\\n  `}function W(n){if(n<=1)return\"int\";if(2===n)return\"ivec2\";if(3===n)return\"ivec3\";if(4===n)return\"ivec4\";if(5===n)return\"ivec5\";if(6===n)return\"ivec6\";throw Error(`GPU for rank ${n} is not yet supported`)}function J(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function K(n,e){return e.map(e=>n[e]).join(\", \")}"},"sourceMaps":null,"error":null,"hash":"2033429db4330fa052471a5b2a1978ef","cacheData":{"env":{}}}