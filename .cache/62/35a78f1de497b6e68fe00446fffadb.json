{"id":"GeqG","dependencies":[{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/package.json","includedInParent":true,"mtime":1609565653941},{"name":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/package.json","includedInParent":true,"mtime":499162500000},{"name":"@tensorflow/tfjs-core","loc":{"line":14,"column":36},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-core/dist/index.js"},{"name":"../backend/tfjs_backend","loc":{"line":15,"column":19},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js"},{"name":"../common","loc":{"line":16,"column":26},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/common.js"},{"name":"../engine/topology","loc":{"line":17,"column":49},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js"},{"name":"../errors","loc":{"line":18,"column":48},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/errors.js"},{"name":"../keras_format/common","loc":{"line":19,"column":48},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/keras_format/common.js"},{"name":"../utils/generic_utils","loc":{"line":20,"column":31},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js"},{"name":"../utils/types_utils","loc":{"line":21,"column":56},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js"},{"name":"./recurrent","loc":{"line":22,"column":37},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/recurrent.js"},{"name":"./serialization","loc":{"line":23,"column":28},"parent":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","resolved":"/Users/humengqiao/Desktop/node-project/trash-classify/node_modules/@tensorflow/tfjs-layers/dist/layers/serialization.js"}],"generated":{"js":"\"use strict\";Object.defineProperty(exports,\"__esModule\",{value:!0}),exports.checkBidirectionalMergeMode=y,exports.Bidirectional=exports.TimeDistributed=exports.Wrapper=void 0;var e=h(require(\"@tensorflow/tfjs-core\")),t=h(require(\"../backend/tfjs_backend\")),r=require(\"../common\"),a=require(\"../engine/topology\"),i=require(\"../errors\"),s=require(\"../keras_format/common\"),n=h(require(\"../utils/generic_utils\")),l=require(\"../utils/types_utils\"),o=require(\"./recurrent\"),c=require(\"./serialization\");function u(){if(\"function\"!=typeof WeakMap)return null;var e=new WeakMap;return u=function(){return e},e}function h(e){if(e&&e.__esModule)return e;if(null===e||\"object\"!=typeof e&&\"function\"!=typeof e)return{default:e};var t=u();if(t&&t.has(e))return t.get(e);var r={},a=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var i in e)if(Object.prototype.hasOwnProperty.call(e,i)){var s=a?Object.getOwnPropertyDescriptor(e,i):null;s&&(s.get||s.set)?Object.defineProperty(r,i,s):r[i]=e[i]}return r.default=e,t&&t.set(e,r),r}class d extends a.Layer{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const a=t.layer,i=(0,c.deserialize)(a,r);delete t.layer;const s={layer:i};return Object.assign(s,t),new e(s)}}exports.Wrapper=d;class g extends d{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=(0,l.getExactlyOneShape)(e)).length<3)throw new i.ValueError(\"TimeDistributed layer expects an input shape >= 3D, but received \"+`input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=(0,l.getExactlyOneShape)(e))[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),a=e[1];return[r[0],a].concat(r.slice(1))}call(t,r){return(0,e.tidy)(()=>{t=(0,l.getExactlyOneTensor)(t);return(0,o.rnn)((e,t)=>{return[(0,l.getExactlyOneTensor)(this.layer.call(e,r)),[]]},t,[],!1,null,null,!1,!0)[1]})}}function y(e){n.checkStringTypeUnionValue(s.VALID_BIDIRECTIONAL_MERGE_MODES,\"BidirectionalMergeMode\",e)}exports.TimeDistributed=g,g.className=\"TimeDistributed\",e.serialization.registerClass(g);const p=\"concat\";class f extends d{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=(0,c.deserialize)(r),t.goBackwards=!0!==t.goBackwards;const a={};if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=(0,c.deserialize)(a),this.forwardLayer.name=\"forward_\"+this.forwardLayer.name,this.backwardLayer.name=\"backward_\"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?p:e.mergeMode,y(this.mergeMode),e.weights)throw new i.NotImplementedError(\"weights support is not implemented for Bidirectional layer yet.\");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t,r,a,i=this.forwardLayer.computeOutputShape(e);return Array.isArray(i)&&Array.isArray(i[0])||(i=[i]),i=i,this.returnState?(a=i.slice(1),t=i[0]):t=i[0],t=t,\"concat\"===this.mergeMode?(t[t.length-1]*=2,r=[t]):r=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?r.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):n.singletonOrArray(r)}apply(e,t){let r=null==t?null:t.initialState,s=null==t?null:t.constants;null==t&&(t={});const n=(0,o.standardizeArgs)(e,r,s,this.numConstants);if(e=n.inputs,r=n.initialState,s=n.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(null==r||0===r.length)&&null==s)return super.apply(e,t);const l=[],c=[];if(null!=r){const e=r.length;if(e%2>0)throw new i.ValueError(\"When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.\");t.initialState=r,l.push(...r);const s=r.map(e=>new a.InputSpec({shape:e.shape}));this.forwardLayer.stateSpec=s.slice(0,e/2),this.backwardLayer.stateSpec=s.slice(e/2),c.push(...s)}if(null!=s)throw new i.NotImplementedError(\"Support for constants in Bidirectional layers is not implemented yet.\");const u=l[0]instanceof a.SymbolicTensor;for(const o of l)if(o instanceof a.SymbolicTensor!==u)throw new i.ValueError(\"The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors\");if(u){const r=[e].concat(l),a=this.inputSpec.concat(c),i=this.inputSpec;this.inputSpec=a;const s=super.apply(r,t);return this.inputSpec=i,s}return super.apply(e,t)}call(r,a){return(0,e.tidy)(()=>{const i=a.initialState;let s,n,l,o;if(null==i)s=this.forwardLayer.call(r,a),n=this.backwardLayer.call(r,a);else{const e=i.slice(0,i.length/2),t=i.slice(i.length/2);s=this.forwardLayer.call(r,Object.assign(a,{initialState:e})),n=this.backwardLayer.call(r,Object.assign(a,{initialState:t}))}return this.returnState&&(Array.isArray(s)&&(l=s.slice(1).concat(n.slice(1))),s=s[0],n=n[0]),this.returnSequences&&(n=e.reverse(n,1)),\"concat\"===this.mergeMode?o=t.concatenate([s,n]):\"sum\"===this.mergeMode?o=e.add(s,n):\"ave\"===this.mergeMode?o=e.mul(.5,e.add(s,n)):\"mul\"===this.mergeMode?o=e.mul(s,n):null==this.mergeMode&&(o=[s,n]),this.returnState?null==this.mergeMode?o.concat(l):[o].concat(l):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){(0,r.nameScope)(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),(0,r.nameScope)(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){let r;if(Array.isArray(t)&&(t=t[0]),r=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map(e=>null);return Array.isArray(r)?r.concat(e).concat(e):[r].concat(e).concat(e)}return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=(0,c.deserialize)(t.layer);if(delete t.layer,null!=t.numConstants)throw new i.NotImplementedError(\"Deserialization of a Bidirectional layer with numConstants present is not supported yet.\");const a=t;return a.layer=r,new e(a)}}exports.Bidirectional=f,f.className=\"Bidirectional\",e.serialization.registerClass(f);"},"sourceMaps":null,"error":null,"hash":"670e7b5666f444275739cce835dcb2ad","cacheData":{"env":{}}}